# ä¸Šç˜¾å¼å¹¿å‘Šç®¡ç†ç³»ç»Ÿè®¾è®¡æ–‡æ¡£

## æ¦‚è¿°

æœ¬è®¾è®¡æ–‡æ¡£åŸºäºéœ€æ±‚æ–‡æ¡£ä¸­çš„18ä¸ªæ ¸å¿ƒéœ€æ±‚ï¼Œæä¾›äº†å®Œæ•´çš„æŠ€æœ¯æ¶æ„ã€ç»„ä»¶è®¾è®¡ã€æ•°æ®æ¨¡å‹å’Œå®ç°æ–¹æ¡ˆã€‚ç³»ç»Ÿé‡‡ç”¨å¾®æœåŠ¡æ¶æ„ï¼Œå……åˆ†åˆ©ç”¨Google Cloud Platformçš„æŠ€æœ¯æ ˆï¼Œå®ç°é«˜æ€§èƒ½ã€å¯æ‰©å±•çš„å¹¿å‘Šç®¡ç†å¹³å°ã€‚

## ç³»ç»Ÿæ¶æ„

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å‰ç«¯å±‚ (Frontend)                        â”‚
â”‚                    Next.js + Firebase Hosting                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      APIç½‘å…³å±‚ (API Gateway)                    â”‚
â”‚                   Google Cloud API Gateway                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ä¸šåŠ¡é€»è¾‘å±‚ (Business Logic)                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚Offerç®¡ç†æœåŠ¡â”‚ â”‚è¯„ä¼°åˆ†ææœåŠ¡ â”‚ â”‚æ‰¹é‡æ“ä½œæœåŠ¡ â”‚ â”‚URLè§£ææœåŠ¡  â”‚â”‚
â”‚  â”‚             â”‚ â”‚             â”‚ â”‚             â”‚ â”‚(å¸¸é©»æœåŠ¡)   â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                        Google Cloud Run                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     å®šæ—¶ä»»åŠ¡å±‚ (Scheduled Tasks)                â”‚
â”‚  Cloud Scheduler â†’ Pub/Sub â†’ Cloud Functions â†’ Cloud Run       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      æ•°æ®å­˜å‚¨å±‚ (Data Storage)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚  Firestore  â”‚ â”‚ Cloud SQL   â”‚ â”‚Cloud Storageâ”‚ â”‚Secret Mgr   â”‚â”‚
â”‚  â”‚é…ç½®/çŠ¶æ€/ç¼“å­˜â”‚ â”‚å†å²/åˆ†ææ•°æ®â”‚ â”‚æ–‡ä»¶/æ—¥å¿—å­˜å‚¨â”‚ â”‚å¯†é’¥ç®¡ç†     â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     å¤–éƒ¨é›†æˆå±‚ (External APIs)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚Google Ads   â”‚ â”‚SimilarWeb   â”‚ â”‚Firebase AI  â”‚ â”‚ä»£ç†IPæœåŠ¡   â”‚â”‚
â”‚  â”‚    API      â”‚ â”‚    API      â”‚ â”‚   Logic     â”‚ â”‚             â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```## 
æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 1. Offerç®¡ç†æœåŠ¡ (Offer Management Service)

**èŒè´£ï¼š** ç®¡ç†Offerçš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸï¼ŒåŒ…æ‹¬çŠ¶æ€æµè½¬ã€æ•°æ®å­˜å‚¨ã€æƒé™æ§åˆ¶

**æŠ€æœ¯æ ˆï¼š** Go + Cloud Run + Firestore

**æ ¸å¿ƒåŠŸèƒ½ï¼š**
- Offer CRUDæ“ä½œ
- çŠ¶æ€æµè½¬ç®¡ç†ï¼ˆæœºä¼šæ± â†’è¯„ä¼°ä¸­â†’ä»¿çœŸä¸­â†’æ”¾å¤§ä¸­â†’è¡°é€€æœŸâ†’å½’æ¡£ï¼‰
- æ‰¹é‡å½•å…¥å’Œæƒé™éªŒè¯
- ROSCè®¡ç®—å’Œå†å²è®°å½•

**APIè®¾è®¡ï¼š**
```go
// Offerç®¡ç†API
POST   /api/v1/offers                    // åˆ›å»ºOffer
GET    /api/v1/offers                    // è·å–Offeråˆ—è¡¨
GET    /api/v1/offers/{id}               // è·å–Offerè¯¦æƒ…
PUT    /api/v1/offers/{id}               // æ›´æ–°Offer
DELETE /api/v1/offers/{id}               // åˆ é™¤Offer
PUT    /api/v1/offers/{id}/status        // æ›´æ–°OfferçŠ¶æ€
POST   /api/v1/offers/batch              // æ‰¹é‡å½•å…¥Offer
GET    /api/v1/offers/{id}/history       // è·å–Offerå†å²è®°å½•
```

### 2. æ™ºèƒ½è¯„ä¼°åˆ†ææœåŠ¡ (Evaluation & Analysis Service)

**èŒè´£ï¼š** æä¾›Offerè¯„ä¼°ã€å¸‚åœºåˆ†æã€æœºä¼šå‘ç°ç­‰æ™ºèƒ½åˆ†æåŠŸèƒ½

**æŠ€æœ¯æ ˆï¼š** Go + Cloud Run + Firebase AI Logic + SimilarWeb API

**æ ¸å¿ƒåŠŸèƒ½ï¼š**
- URLè§£æå’Œè½åœ°é¡µåˆ†æ
- æµé‡æ•°æ®è·å–å’Œåˆ†æ
- å­£èŠ‚æ€§æ³¢åŠ¨åˆ†æ
- 0-100åˆ†è¯„åˆ†ç®—æ³•
- ç›¸ä¼¼æœºä¼šå‘ç°

**APIè®¾è®¡ï¼š**
```go
// è¯„ä¼°åˆ†æAPI
POST   /api/v1/evaluation/analyze        // åˆ†æOffer URL
GET    /api/v1/evaluation/{id}/score     // è·å–è¯„ä¼°è¯„åˆ†
POST   /api/v1/evaluation/similar        // å‘ç°ç›¸ä¼¼æœºä¼š
GET    /api/v1/evaluation/market-trends  // è·å–å¸‚åœºè¶‹åŠ¿
POST   /api/v1/evaluation/batch-analyze  // æ‰¹é‡åˆ†æ
```

### 3. æ‰¹é‡æ“ä½œæœåŠ¡ (Bulk Operations Service)

**èŒè´£ï¼š** å¤„ç†å¤šè´¦æˆ·æ‰¹é‡æ“ä½œï¼ŒåŒ…æ‹¬æ¢é“¾æ¥ã€A/Bæµ‹è¯•ã€CPCè°ƒæ•´ç­‰

**æŠ€æœ¯æ ˆï¼š** Go + Cloud Run + Google Ads API

**æ ¸å¿ƒåŠŸèƒ½ï¼š**
- ä»¥Offerä¸ºä¸­å¿ƒçš„æ‰¹é‡æ“ä½œç•Œé¢
- è‡ªåŠ¨å…³è”Offerä¸‹çš„æ‰€æœ‰Google Adsè´¦æˆ·å’Œå¹¿å‘Šç»„
- æ™ºèƒ½ç­›é€‰å’Œæ“ä½œé¢„è§ˆ
- æ¢é“¾æ¥å®šæ—¶ä»»åŠ¡
- A/Bæµ‹è¯•ç®¡ç†
- æ“ä½œå†å²å’Œæ’¤é”€

**APIè®¾è®¡ï¼š**
```go
// æ‰¹é‡æ“ä½œAPI
POST   /api/v1/bulk/operations           // æ‰§è¡Œæ‰¹é‡æ“ä½œ
GET    /api/v1/bulk/operations/{id}      // è·å–æ“ä½œçŠ¶æ€
POST   /api/v1/bulk/preview              // æ“ä½œé¢„è§ˆ
POST   /api/v1/bulk/rollback/{id}        // å›æ»šæ“ä½œ
POST   /api/v1/bulk/link-rotation        // é…ç½®æ¢é“¾æ¥
GET    /api/v1/bulk/ab-tests             // è·å–A/Bæµ‹è¯•åˆ—è¡¨
POST   /api/v1/bulk/ab-tests             // åˆ›å»ºA/Bæµ‹è¯•
```

### 4. URLè§£ææœåŠ¡ (URL Parsing Service) - å¸¸é©»æœåŠ¡

**èŒè´£ï¼š** æä¾›é«˜æ€§èƒ½çš„URLè§£æèƒ½åŠ›ï¼Œå¤„ç†å¤šé‡é‡å®šå‘å’Œåæ£€æµ‹

**æŠ€æœ¯æ ˆï¼š** Go + Cloud Run (å¸¸é©») + Playwright + ä»£ç†IPæ± 

**æ¶æ„ç‰¹ç‚¹ï¼š**
- å¸¸é©»æœåŠ¡ï¼Œç»´æŒæœ€å°1ä¸ªå®ä¾‹
- æµè§ˆå™¨å®ä¾‹æ± ç®¡ç†
- æ™ºèƒ½ä»£ç†IPè½®æ¢
- æ‰¹é‡å¤„ç†æ”¯æŒ

**æ ¸å¿ƒåŠŸèƒ½ï¼š**
- å¤šé‡é‡å®šå‘è§£æ
- Final URLå’Œsuffixæå–
- æ™ºèƒ½ä»£ç†IPå¤ç”¨ç­–ç•¥
- åæ£€æµ‹ç­–ç•¥
- åœ°åŸŸåŒ–é…ç½®ï¼ˆæ—¶åŒºã€è¯­è¨€ã€User-Agentï¼‰
- æ‰¹é‡è§£æä¼˜åŒ–

**APIè®¾è®¡ï¼š**
```go
// URLè§£æAPI
POST   /api/v1/url-parser/parse          // è§£æå•ä¸ªURL
POST   /api/v1/url-parser/batch-parse    // æ‰¹é‡è§£æURL
GET    /api/v1/url-parser/health         // æœåŠ¡å¥åº·æ£€æŸ¥
POST   /api/v1/url-parser/proxy/rotate   // è½®æ¢ä»£ç†IP
GET    /api/v1/url-parser/stats          // è·å–è§£æç»Ÿè®¡
```

**å®ä¾‹æ± ç®¡ç†ï¼š**
```go
type BrowserPool struct {
    browsers    []*playwright.Browser
    maxSize     int
    currentSize int
    mutex       sync.RWMutex
}

func (p *BrowserPool) GetBrowser() *playwright.Browser
func (p *BrowserPool) ReleaseBrowser(browser *playwright.Browser)
func (p *BrowserPool) HealthCheck() error

// æ™ºèƒ½ä»£ç†IPç®¡ç†
type ProxyManager struct {
    countryPools map[string]*CountryProxyPool
    timeWindow   time.Duration // 5åˆ†é’Ÿå¤ç”¨çª—å£
}

type CountryProxyPool struct {
    currentIP    string
    usedByOffers map[string]bool // è®°å½•å·²ä½¿ç”¨æ­¤IPçš„Offer URL
    lastRotation time.Time
    apiURL       string // è¯¥å›½å®¶çš„ä»£ç†IP API URL
}

func (pm *ProxyManager) GetProxyForOffer(country, offerURL string) string
func (pm *ProxyManager) ConfigureCountryAPI(country, apiURL string) error
```

### 5. AIé¢„è­¦ä¸ä¼˜åŒ–æœåŠ¡ (AI Alert & Optimization Service)

**èŒè´£ï¼š** æä¾›æ™ºèƒ½é¢„è­¦ã€é£é™©è¯†åˆ«ã€ä¼˜åŒ–å»ºè®®ç­‰AIé©±åŠ¨åŠŸèƒ½

**æŠ€æœ¯æ ˆï¼š** Go + Cloud Run + Firebase AI Logic + è§„åˆ™å¼•æ“

**æ ¸å¿ƒåŠŸèƒ½ï¼š**
- å®æ—¶æ•°æ®ç›‘æ§å’Œè‡ªåŠ¨çŠ¶æ€è½¬æ¢ï¼ˆè¿ç»­5å¤©0æ›å…‰0ç‚¹å‡»â†’è¡°é€€æœŸï¼‰
- é£é™©è¯†åˆ«å’Œé¢„è­¦
- Firebase AI Logicå¤šåœºæ™¯åº”ç”¨ï¼šå†…å®¹åˆ†æã€ä¼˜åŒ–å»ºè®®ã€åˆè§„æ£€æŸ¥
- æ•ˆæœè·Ÿè¸ªåé¦ˆ
- è§„åˆ™å¼•æ“ç®¡ç†

**APIè®¾è®¡ï¼š**
```go
// AIé¢„è­¦ä¼˜åŒ–API
GET    /api/v1/ai/alerts                 // è·å–é¢„è­¦åˆ—è¡¨
POST   /api/v1/ai/alerts/acknowledge     // ç¡®è®¤é¢„è­¦
GET    /api/v1/ai/suggestions            // è·å–ä¼˜åŒ–å»ºè®®
POST   /api/v1/ai/suggestions/apply      // åº”ç”¨å»ºè®®
GET    /api/v1/ai/insights               // è·å–AIæ´å¯Ÿ
POST   /api/v1/ai/rules                  // é…ç½®é¢„è­¦è§„åˆ™
POST   /api/v1/ai/analyze-content        // Firebase AIå†…å®¹åˆ†æ
POST   /api/v1/ai/compliance-check       // Firebase AIåˆè§„æ£€æŸ¥
POST   /api/v1/ai/generate-suggestions   // Firebase AIä¼˜åŒ–å»ºè®®
```

### 6. æ•°æ®åŒæ­¥æœåŠ¡ (Data Sync Service)

**èŒè´£ï¼š** ç®¡ç†ä¸Google Ads APIçš„æ•°æ®åŒæ­¥ï¼Œæä¾›å…¨å±€æ•°æ®è§†å›¾

**æŠ€æœ¯æ ˆï¼š** Go + Cloud Run + Google Ads API + Cloud SQL

**æ ¸å¿ƒåŠŸèƒ½ï¼š**
- å¢é‡æ•°æ®åŒæ­¥
- å¤šè´¦æˆ·æ•°æ®èšåˆ
- è¶‹åŠ¿æ•°æ®è®¡ç®—
- APIé™åˆ¶ç®¡ç†
- æ•°æ®è´¨é‡ç›‘æ§

**APIè®¾è®¡ï¼š**
```go
// æ•°æ®åŒæ­¥API
POST   /api/v1/sync/trigger              // è§¦å‘åŒæ­¥
GET    /api/v1/sync/status               // è·å–åŒæ­¥çŠ¶æ€
GET    /api/v1/sync/dashboard            // è·å–ä»ªè¡¨ç›˜æ•°æ®
GET    /api/v1/sync/trends               // è·å–è¶‹åŠ¿æ•°æ®
POST   /api/v1/sync/accounts/connect     // è¿æ¥Google Adsè´¦æˆ·
```

### 7. åå°ç®¡ç†æœåŠ¡ (Admin Management Service)

**èŒè´£ï¼š** æä¾›å®Œæ•´çš„åå°ç®¡ç†åŠŸèƒ½ï¼ŒåŒ…æ‹¬ä»ªè¡¨ç›˜ã€ç”¨æˆ·ç®¡ç†ã€å¥—é¤ç®¡ç†ã€Tokenç®¡ç†ã€åŠ¨æ€é…ç½®

**æŠ€æœ¯æ ˆï¼š** Go + Cloud Run + Firestore + Cloud SQL

**æ ¸å¿ƒåŠŸèƒ½ï¼š**
- å®æ—¶ä»ªè¡¨ç›˜æ•°æ®èšåˆ
- ç”¨æˆ·ç”Ÿå‘½å‘¨æœŸç®¡ç†
- å¥—é¤å’Œæƒé™é…ç½®
- Tokenæ¶ˆè€—ç›‘æ§å’Œç®¡ç†
- åŠ¨æ€é…ç½®çƒ­æ›´æ–°

**APIè®¾è®¡ï¼š**
```go
// ä»ªè¡¨ç›˜API
GET    /api/v1/admin/dashboard/stats     // è·å–ç»Ÿè®¡æ•°æ®
GET    /api/v1/admin/dashboard/revenue   // è·å–æ”¶å…¥ç»Ÿè®¡
GET    /api/v1/admin/dashboard/health    // è·å–ç³»ç»Ÿå¥åº·çŠ¶æ€
GET    /api/v1/admin/dashboard/activity  // è·å–ç”¨æˆ·æ´»è·ƒåº¦

// ç”¨æˆ·ç®¡ç†API
GET    /api/v1/admin/users               // è·å–ç”¨æˆ·åˆ—è¡¨
GET    /api/v1/admin/users/{id}          // è·å–ç”¨æˆ·è¯¦æƒ…
PUT    /api/v1/admin/users/{id}/status   // æ›´æ–°ç”¨æˆ·çŠ¶æ€
PUT    /api/v1/admin/users/{id}/plan     // å˜æ›´ç”¨æˆ·å¥—é¤
POST   /api/v1/admin/users/{id}/tokens   // å……å€¼Token
GET    /api/v1/admin/users/{id}/logs     // è·å–ç”¨æˆ·æ“ä½œæ—¥å¿—

// å¥—é¤ç®¡ç†API
GET    /api/v1/admin/plans               // è·å–å¥—é¤åˆ—è¡¨
POST   /api/v1/admin/plans               // åˆ›å»ºå¥—é¤
PUT    /api/v1/admin/plans/{id}          // æ›´æ–°å¥—é¤
DELETE /api/v1/admin/plans/{id}          // åˆ é™¤å¥—é¤
GET    /api/v1/admin/plans/{id}/users    // è·å–å¥—é¤ç”¨æˆ·

// Tokenç®¡ç†API
GET    /api/v1/admin/tokens/stats        // è·å–Tokenç»Ÿè®¡
GET    /api/v1/admin/tokens/consumption  // è·å–æ¶ˆè€—è§„åˆ™
PUT    /api/v1/admin/tokens/rules        // æ›´æ–°æ¶ˆè€—è§„åˆ™
POST   /api/v1/admin/tokens/bulk-recharge // æ‰¹é‡å……å€¼
GET    /api/v1/admin/tokens/alerts       // è·å–å¼‚å¸¸é¢„è­¦

// åŠ¨æ€é…ç½®API
GET    /api/v1/admin/configs             // è·å–æ‰€æœ‰é…ç½®
GET    /api/v1/admin/configs/{section}   // è·å–ç‰¹å®šé…ç½®
PUT    /api/v1/admin/configs/{section}   // æ›´æ–°é…ç½®
GET    /api/v1/admin/configs/history     // è·å–é…ç½®å†å²
POST   /api/v1/admin/configs/rollback    // å›æ»šé…ç½®

// APIç›‘æ§ç®¡ç†API
GET    /api/v1/admin/api-monitor/stats   // è·å–APIè°ƒç”¨ç»Ÿè®¡
GET    /api/v1/admin/api-monitor/quota   // è·å–é…é¢ä½¿ç”¨æƒ…å†µ
PUT    /api/v1/admin/api-monitor/limits  // è®¾ç½®è°ƒç”¨é™åˆ¶
GET    /api/v1/admin/api-monitor/alerts  // è·å–APIé¢„è­¦

// ç‚¹å‡»ä¼˜åŒ–åˆ†æAPI
GET    /api/v1/admin/click-analysis/stats // è·å–ç‚¹å‡»åˆ†æç»Ÿè®¡
POST   /api/v1/admin/click-analysis/optimize // æ‰§è¡ŒAIä¼˜åŒ–åˆ†æ
PUT    /api/v1/admin/click-analysis/strategy // æ›´æ–°ç‚¹å‡»ç­–ç•¥
POST   /api/v1/admin/click-analysis/deploy   // éƒ¨ç½²ä¼˜åŒ–ç­–ç•¥åˆ°URLè§£ææœåŠ¡
```## 
æ•°æ®æ¨¡å‹è®¾è®¡

### Firestore æ•°æ®ç»“æ„

#### 1. ç”¨æˆ·ç›¸å…³é›†åˆ

```javascript
// /users/{userId}
{
  profile: {
    email: string,
    displayName: string,
    createdAt: timestamp,
    lastLoginAt: timestamp
  },
  subscription: {
    plan: "Pro" | "Max" | "Elite",
    status: "active" | "expired" | "suspended",
    expiresAt: timestamp,
    tokensRemaining: number,
    features: string[]
  },
  settings: {
    defaultCountry: string,
    timezone: string,
    notifications: {
      email: boolean,
      push: boolean,
      alerts: boolean
    },
    ui: {
      theme: "light" | "dark",
      language: string,
      dashboardLayout: object
    }
  }
}

// /users/{userId}/notifications/{notificationId}
{
  type: "alert" | "suggestion" | "info",
  title: string,
  message: string,
  data: object,
  read: boolean,
  createdAt: timestamp,
  expiresAt: timestamp
}
```

#### 2. Offerç›¸å…³é›†åˆ

```javascript
// /offers/{offerId}
{
  basic: {
    url: string,
    finalUrl: string,
    finalUrlSuffix: string,
    country: string,
    status: "pool" | "evaluating" | "simulating" | "scaling" | "declining" | "archived",
    createdAt: timestamp,
    updatedAt: timestamp,
    userId: string
  },
  evaluation: {
    score: number, // 0-100
    dimensions: {
      trafficPotential: number,
      keywordRelevance: number,
      cpcCost: number,
      complianceRisk: number,
      seasonalOpportunity: number
    },
    analysis: {
      industry: string,
      productType: string,
      targetAudience: string,
      estimatedCpc: number,
      trafficVolume: number,
      competitionLevel: string
    },
    evaluatedAt: timestamp
  },
  simulation: {
    config: {
      dailyClicks: number,
      model: "workday" | "weekend" | "holiday" | "custom",
      customCurve: number[],
      referers: string[]
    },
    status: "running" | "paused" | "completed",
    progress: {
      totalClicks: number,
      successfulClicks: number,
      failedClicks: number,
      successRate: number
    },
    startedAt: timestamp,
    estimatedCompletionAt: timestamp
  },
  performance: {
    rosc: number,
    totalSpend: number,
    totalRevenue: number,
    impressions: number,
    clicks: number,
    ctr: number,
    avgCpc: number,
    qualityScore: number,
    lastUpdatedAt: timestamp
  }
}

// /offers/{offerId}/history/{historyId}
{
  action: "created" | "status_changed" | "evaluation_completed" | "simulation_started",
  fromStatus: string,
  toStatus: string,
  data: object,
  userId: string,
  timestamp: timestamp
}
```

#### 3. ç³»ç»Ÿé…ç½®é›†åˆ

```javascript
// /configs/evaluation_standards
{
  scoring: {
    trafficPotential: {
      weights: object,
      thresholds: object
    },
    keywordRelevance: {
      weights: object,
      thresholds: object
    },
    // ... å…¶ä»–ç»´åº¦é…ç½®
  },
  updatedAt: timestamp,
  updatedBy: string
}

// /configs/risk_rules
{
  rules: [
    {
      id: string,
      name: string,
      condition: string, // è§„åˆ™è¡¨è¾¾å¼
      severity: "low" | "medium" | "high" | "critical",
      action: "alert" | "pause" | "stop",
      enabled: boolean
    }
  ],
  updatedAt: timestamp
}

// /configs/proxy_settings
{
  countryAPIs: {
    "US": "https://api.proxy-provider.com/us",
    "UK": "https://api.proxy-provider.com/uk",
    "CA": "https://api.proxy-provider.com/ca"
  },
  reuseWindow: 300, // 5åˆ†é’Ÿå¤ç”¨çª—å£
  providers: [
    {
      name: string,
      apiUrl: string,
      countries: string[],
      enabled: boolean,
      rateLimit: number
    }
  ],
  rotation: {
    strategy: "smart_reuse" | "round_robin" | "random",
    interval: number
  }
}
```

### Cloud SQL æ•°æ®ç»“æ„

#### 1. å†å²æ•°æ®è¡¨

```sql
-- å¹¿å‘Šè´¦æˆ·è¡¨
CREATE TABLE ads_accounts (
    id VARCHAR(50) PRIMARY KEY,
    user_id VARCHAR(50) NOT NULL,
    account_name VARCHAR(255) NOT NULL,
    account_id VARCHAR(50) NOT NULL,
    currency VARCHAR(3) NOT NULL,
    status ENUM('active', 'suspended', 'cancelled') DEFAULT 'active',
    oauth_token_encrypted TEXT,
    refresh_token_encrypted TEXT,
    token_expires_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_user_id (user_id),
    INDEX idx_account_id (account_id)
);

-- å¹¿å‘Šæ•°æ®å†å²è¡¨
CREATE TABLE ads_performance_history (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    offer_id VARCHAR(50) NOT NULL,
    account_id VARCHAR(50) NOT NULL,
    campaign_id VARCHAR(50),
    ad_group_id VARCHAR(50),
    date DATE NOT NULL,
    impressions BIGINT DEFAULT 0,
    clicks BIGINT DEFAULT 0,
    cost_micros BIGINT DEFAULT 0,
    conversions DECIMAL(10,2) DEFAULT 0,
    conversion_value_micros BIGINT DEFAULT 0,
    ctr DECIMAL(5,4) DEFAULT 0,
    avg_cpc_micros BIGINT DEFAULT 0,
    quality_score DECIMAL(3,1) DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY unique_performance (offer_id, account_id, campaign_id, ad_group_id, date),
    INDEX idx_offer_date (offer_id, date),
    INDEX idx_account_date (account_id, date)
);

-- æ“ä½œå®¡è®¡æ—¥å¿—è¡¨
CREATE TABLE operation_logs (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id VARCHAR(50) NOT NULL,
    operation_type ENUM('bulk_update', 'link_rotation', 'ab_test', 'manual_update') NOT NULL,
    target_type ENUM('campaign', 'ad_group', 'ad', 'keyword') NOT NULL,
    target_ids JSON NOT NULL,
    operation_data JSON NOT NULL,
    status ENUM('pending', 'running', 'completed', 'failed', 'rolled_back') DEFAULT 'pending',
    affected_count INT DEFAULT 0,
    error_message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP NULL,
    INDEX idx_user_created (user_id, created_at),
    INDEX idx_status (status)
);

-- è´¢åŠ¡è®°å½•è¡¨
CREATE TABLE financial_records (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id VARCHAR(50) NOT NULL,
    offer_id VARCHAR(50) NOT NULL,
    record_type ENUM('revenue', 'cost', 'adjustment') NOT NULL,
    amount_micros BIGINT NOT NULL,
    currency VARCHAR(3) NOT NULL,
    description TEXT,
    reference_id VARCHAR(100),
    recorded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_user_offer (user_id, offer_id),
    INDEX idx_recorded_at (recorded_at)
);
```

#### 2. åˆ†ææ•°æ®è¡¨

```sql
-- Offeræ€§èƒ½æ±‡æ€»è¡¨
CREATE TABLE offer_performance_summary (
    offer_id VARCHAR(50) PRIMARY KEY,
    user_id VARCHAR(50) NOT NULL,
    total_spend_micros BIGINT DEFAULT 0,
    total_revenue_micros BIGINT DEFAULT 0,
    total_impressions BIGINT DEFAULT 0,
    total_clicks BIGINT DEFAULT 0,
    avg_ctr DECIMAL(5,4) DEFAULT 0,
    avg_cpc_micros BIGINT DEFAULT 0,
    rosc DECIMAL(8,4) DEFAULT 0,
    connected_accounts_count INT DEFAULT 0,
    first_activity_date DATE,
    last_activity_date DATE,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_user_rosc (user_id, rosc),
    INDEX idx_last_activity (last_activity_date)
);

-- å¸‚åœºè¶‹åŠ¿æ•°æ®è¡¨
CREATE TABLE market_trends (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    industry VARCHAR(100) NOT NULL,
    country VARCHAR(2) NOT NULL,
    metric_name VARCHAR(50) NOT NULL,
    metric_value DECIMAL(15,4) NOT NULL,
    period_type ENUM('daily', 'weekly', 'monthly') NOT NULL,
    period_start DATE NOT NULL,
    period_end DATE NOT NULL,
    data_source VARCHAR(50) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY unique_trend (industry, country, metric_name, period_start),
    INDEX idx_industry_country (industry, country),
    INDEX idx_period (period_start, period_end)
);
```

## å®šæ—¶ä»»åŠ¡æ¶æ„è®¾è®¡

### å®šæ—¶ä»»åŠ¡æµç¨‹å›¾

```
Cloud Scheduler (å®šæ—¶è§¦å‘)
    â†“
Pub/Sub Topics (æ¶ˆæ¯åˆ†å‘)
    â†“
Cloud Functions (ä»»åŠ¡æ‰§è¡Œå™¨)
    â†“
Cloud Run Services (ä¸šåŠ¡å¤„ç†)
```

### 1. è¡¥ç‚¹å‡»ä»»åŠ¡æµç¨‹

```yaml
# Cloud Scheduler Job: click-simulation-scheduler
schedule: "*/5 * * * *"  # æ¯5åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
target:
  pubsub_target:
    topic_name: "click-simulation-topic"
    data: |
      {
        "action": "check_pending_simulations",
        "timestamp": "{{.timestamp}}"
      }
```

```go
// Cloud Function: click-simulation-handler
func HandleClickSimulation(ctx context.Context, m PubSubMessage) error {
    // 1. æŸ¥è¯¢éœ€è¦æ‰§è¡Œçš„è¡¥ç‚¹å‡»ä»»åŠ¡
    tasks := getActiveTasks()
    
    // 2. ä¸ºæ¯ä¸ªä»»åŠ¡è°ƒç”¨URLè§£ææœåŠ¡
    for _, task := range tasks {
        go processClickTask(task)
    }
    
    return nil
}

func processClickTask(task ClickTask) {
    // è°ƒç”¨URLè§£ææœåŠ¡æ‰§è¡Œç‚¹å‡»
    response := callURLParserService(task.OfferURL, task.Config)
    
    // æ›´æ–°ä»»åŠ¡çŠ¶æ€
    updateTaskProgress(task.ID, response)
}
```

### 2. æ¢é“¾æ¥ä»»åŠ¡æµç¨‹

```yaml
# Cloud Scheduler Job: link-rotation-scheduler
schedule: "0 */1 * * *"  # æ¯å°æ—¶æ£€æŸ¥ä¸€æ¬¡
target:
  pubsub_target:
    topic_name: "link-rotation-topic"
    data: |
      {
        "action": "check_rotation_schedule",
        "timestamp": "{{.timestamp}}"
      }
```

```go
// Cloud Function: link-rotation-handler
func HandleLinkRotation(ctx context.Context, m PubSubMessage) error {
    // 1. æŸ¥è¯¢éœ€è¦æ¢é“¾æ¥çš„ä»»åŠ¡
    rotationTasks := getScheduledRotations()
    
    // 2. å¤„ç†æ¯ä¸ªæ¢é“¾æ¥ä»»åŠ¡
    for _, task := range rotationTasks {
        go processLinkRotation(task)
    }
    
    return nil
}

func processLinkRotation(task LinkRotationTask) {
    // 1. è§£ææ–°çš„URLè·å–suffix
    newSuffix := parseOfferURL(task.OfferURL)
    
    // 2. æ‰¹é‡æ›´æ–°Google Ads
    updateAdGroupSuffixes(task.AdGroupIDs, newSuffix)
    
    // 3. è®°å½•æ“ä½œå†å²
    logRotationOperation(task, newSuffix)
}
```

### 3. æ•°æ®åŒæ­¥ä»»åŠ¡æµç¨‹

```yaml
# Cloud Scheduler Job: data-sync-scheduler
schedule: "0 * * * *"  # æ¯å°æ—¶åŒæ­¥ä¸€æ¬¡
target:
  pubsub_target:
    topic_name: "ads-sync-topic"
    data: |
      {
        "action": "sync_ads_data",
        "timestamp": "{{.timestamp}}"
      }
```

```go
// Cloud Function: data-sync-handler
func HandleDataSync(ctx context.Context, m PubSubMessage) error {
    // 1. è·å–æ‰€æœ‰æ´»è·ƒè´¦æˆ·
    accounts := getActiveAdsAccounts()
    
    // 2. å¹¶å‘åŒæ­¥æ•°æ®
    var wg sync.WaitGroup
    for _, account := range accounts {
        wg.Add(1)
        go func(acc AdsAccount) {
            defer wg.Done()
            syncAccountData(acc)
        }(account)
    }
    wg.Wait()
    
    return nil
}

func syncAccountData(account AdsAccount) {
    // 1. è°ƒç”¨Google Ads APIè·å–æ•°æ®
    data := fetchAdsData(account)
    
    // 2. å­˜å‚¨åˆ°Cloud SQL
    storePerformanceData(data)
    
    // 3. æ›´æ–°Firestoreä¸­çš„å®æ—¶æ•°æ®
    updateRealtimeMetrics(account.ID, data)
    
    // 4. æ£€æŸ¥è‡ªåŠ¨çŠ¶æ€è½¬æ¢æ¡ä»¶
    checkAutoStatusTransition(account.UserID, data)
}

func checkAutoStatusTransition(userID string, performanceData []*PerformanceData) {
    offers := getActiveOffers(userID)
    
    for _, offer := range offers {
        // æ£€æŸ¥è¿ç»­5å¤©0æ›å…‰0ç‚¹å‡»
        if hasZeroPerformanceFor5Days(offer.ID, performanceData) {
            updateOfferStatus(offer.ID, "declining")
            sendStatusChangeNotification(userID, offer.ID, "è‡ªåŠ¨è½¬å…¥è¡°é€€æœŸï¼šè¿ç»­5å¤©æ— æ›å…‰æ— ç‚¹å‡»")
        }
        
        // æ£€æŸ¥ROSCè¿ç»­ä¸‹æ»‘
        if hasROSCDeclineFor7Days(offer.ID, performanceData) {
            updateOfferStatus(offer.ID, "declining")
            sendStatusChangeNotification(userID, offer.ID, "è‡ªåŠ¨è½¬å…¥è¡°é€€æœŸï¼šROSCè¿ç»­ä¸‹æ»‘")
        }
    }
}
```

## å‰ç«¯æ¶æ„è®¾è®¡

### å‰ç«¯æŠ€æœ¯æ ˆæ¶æ„

#### ç”¨æˆ·å‰ç«¯ (User Frontend)
- **æ¡†æ¶ï¼š** Next.js 14 (App Router)
- **çŠ¶æ€ç®¡ç†ï¼š** Zustand + React Query
- **UIç»„ä»¶ï¼š** Tailwind CSS + Headless UI
- **å›¾è¡¨åº“ï¼š** Recharts
- **æ‹–æ‹½äº¤äº’ï¼š** @dnd-kit/core
- **åŠ¨ç”»ï¼š** Framer Motion
- **å®æ—¶é€šä¿¡ï¼š** Firebase SDK (Firestoreå®æ—¶ç›‘å¬)
- **éƒ¨ç½²ï¼š** Firebase Hosting

#### åå°ç®¡ç† (Admin Backend)
- **æ¡†æ¶ï¼š** Next.js 14 (App Router)
- **çŠ¶æ€ç®¡ç†ï¼š** Zustand + React Query
- **UIç»„ä»¶ï¼š** Ant Design 5.x
- **å›¾è¡¨åº“ï¼š** ECharts
- **è¡¨æ ¼ç»„ä»¶ï¼š** Ant Design Table
- **è¡¨å•ç»„ä»¶ï¼š** Ant Design Form
- **å¸ƒå±€ï¼š** Ant Design Pro Layout
- **éƒ¨ç½²ï¼š** Firebase Hosting (ç‹¬ç«‹å­åŸŸå)

### é¡µé¢ç»“æ„è®¾è®¡

```
src/
â”œâ”€â”€ app/                          # Next.js App Router
â”‚   â”œâ”€â”€ (auth)/                   # è®¤è¯ç›¸å…³é¡µé¢
â”‚   â”‚   â”œâ”€â”€ login/
â”‚   â”‚   â””â”€â”€ register/
â”‚   â”œâ”€â”€ (dashboard)/              # ä¸»è¦ä¸šåŠ¡é¡µé¢
â”‚   â”‚   â”œâ”€â”€ offers/               # Offerç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx          # OfferæŒ‡æŒ¥ä¸­å¿ƒ
â”‚   â”‚   â”‚   â”œâ”€â”€ [id]/             # Offerè¯¦æƒ…
â”‚   â”‚   â”‚   â””â”€â”€ evaluation/       # è¯„ä¼°é¡µé¢
â”‚   â”‚   â”œâ”€â”€ dashboard/            # å…¨å±€ä»ªè¡¨ç›˜
â”‚   â”‚   â”œâ”€â”€ operations/           # æ‰¹é‡æ“ä½œ
â”‚   â”‚   â”œâ”€â”€ insights/             # AIæ´å¯Ÿ
â”‚   â”‚   â””â”€â”€ settings/             # è®¾ç½®é¡µé¢
â”‚   â””â”€â”€ api/                      # API Routes (ä»£ç†)
â”œâ”€â”€ components/                   # å¯å¤ç”¨ç»„ä»¶
â”‚   â”œâ”€â”€ ui/                       # åŸºç¡€UIç»„ä»¶
â”‚   â”œâ”€â”€ charts/                   # å›¾è¡¨ç»„ä»¶
â”‚   â”œâ”€â”€ forms/                    # è¡¨å•ç»„ä»¶
â”‚   â””â”€â”€ layout/                   # å¸ƒå±€ç»„ä»¶
â”œâ”€â”€ hooks/                        # è‡ªå®šä¹‰Hooks
â”œâ”€â”€ stores/                       # ZustandçŠ¶æ€ç®¡ç†
â”œâ”€â”€ lib/                          # å·¥å…·å‡½æ•°
â””â”€â”€ types/                        # TypeScriptç±»å‹å®šä¹‰
```

### æ ¸å¿ƒç»„ä»¶è®¾è®¡

#### 1. OfferæŒ‡æŒ¥ä¸­å¿ƒç»„ä»¶

```tsx
// components/offers/OfferCommandCenter.tsx
interface OfferCommandCenterProps {
  userId: string;
}

export function OfferCommandCenter({ userId }: OfferCommandCenterProps) {
  const { offers, updateOfferStatus } = useOffers(userId);
  const { subscription } = useSubscription(userId);
  
  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;
    if (over && active.id !== over.id) {
      updateOfferStatus(active.id as string, over.id as OfferStatus);
    }
  };

  return (
    <DndContext onDragEnd={handleDragEnd}>
      <div className="grid grid-cols-6 gap-4">
        {OFFER_STAGES.map(stage => (
          <OfferStageColumn
            key={stage}
            stage={stage}
            offers={offers.filter(o => o.status === stage)}
            canDrop={subscription.plan !== 'Pro' || stage !== 'scaling'}
          />
        ))}
      </div>
    </DndContext>
  );
}
```

#### 2. æ™ºèƒ½è¯„ä¼°ç»„ä»¶

```tsx
// components/evaluation/OfferEvaluator.tsx
interface OfferEvaluatorProps {
  onEvaluationComplete: (result: EvaluationResult) => void;
}

export function OfferEvaluator({ onEvaluationComplete }: OfferEvaluatorProps) {
  const [url, setUrl] = useState('');
  const [isEvaluating, setIsEvaluating] = useState(false);
  const [progress, setProgress] = useState(0);

  const handleEvaluate = async () => {
    setIsEvaluating(true);
    setProgress(0);

    try {
      // å®æ—¶è¿›åº¦æ›´æ–°
      const progressInterval = setInterval(() => {
        setProgress(prev => Math.min(prev + 10, 90));
      }, 1000);

      const result = await evaluateOffer(url);
      
      clearInterval(progressInterval);
      setProgress(100);
      
      // æˆåŠŸéŸ³æ•ˆå’ŒåŠ¨ç”»
      if (result.score > 80) {
        playSuccessSound();
        showSuccessAnimation();
      }
      
      onEvaluationComplete(result);
    } catch (error) {
      handleEvaluationError(error);
    } finally {
      setIsEvaluating(false);
    }
  };

  return (
    <div className="evaluation-container">
      <URLInput 
        value={url} 
        onChange={setUrl}
        disabled={isEvaluating}
      />
      
      {isEvaluating && (
        <ProgressBar 
          progress={progress}
          message="æ­£åœ¨åˆ†æOfferä»·å€¼..."
        />
      )}
      
      <EvaluateButton 
        onClick={handleEvaluate}
        disabled={!url || isEvaluating}
      />
    </div>
  );
}
```

#### 3. æ‰¹é‡æ“ä½œçŸ©é˜µç»„ä»¶

```tsx
// components/operations/BulkOperationsMatrix.tsx
export function BulkOperationsMatrix() {
  const { campaigns, selectedCampaigns, setSelectedCampaigns } = useCampaigns();
  const { filters, setFilters } = useFilters();
  const [operation, setOperation] = useState<BulkOperation | null>(null);

  const filteredCampaigns = useMemo(() => {
    return campaigns.filter(campaign => {
      return applyFilters(campaign, filters);
    });
  }, [campaigns, filters]);

  const handleBulkOperation = async (op: BulkOperation) => {
    const preview = await previewBulkOperation(selectedCampaigns, op);
    
    if (await confirmOperation(preview)) {
      const result = await executeBulkOperation(selectedCampaigns, op);
      showOperationResult(result);
    }
  };

  return (
    <div className="bulk-operations-matrix">
      <FilterPanel 
        filters={filters}
        onFiltersChange={setFilters}
      />
      
      <DataGrid
        data={filteredCampaigns}
        selectedRows={selectedCampaigns}
        onSelectionChange={setSelectedCampaigns}
        columns={CAMPAIGN_COLUMNS}
      />
      
      <OperationPanel
        selectedCount={selectedCampaigns.length}
        onOperation={handleBulkOperation}
      />
    </div>
  );
}
```

### çŠ¶æ€ç®¡ç†è®¾è®¡

#### 1. OfferçŠ¶æ€ç®¡ç†

```typescript
// stores/offerStore.ts
interface OfferState {
  offers: Offer[];
  selectedOffer: Offer | null;
  loading: boolean;
  error: string | null;
}

interface OfferActions {
  fetchOffers: (userId: string) => Promise<void>;
  createOffer: (offer: CreateOfferRequest) => Promise<void>;
  updateOfferStatus: (offerId: string, status: OfferStatus) => Promise<void>;
  deleteOffer: (offerId: string) => Promise<void>;
  selectOffer: (offer: Offer) => void;
  clearError: () => void;
}

export const useOfferStore = create<OfferState & OfferActions>((set, get) => ({
  offers: [],
  selectedOffer: null,
  loading: false,
  error: null,

  fetchOffers: async (userId: string) => {
    set({ loading: true, error: null });
    try {
      const offers = await offerService.getOffers(userId);
      set({ offers, loading: false });
    } catch (error) {
      set({ error: error.message, loading: false });
    }
  },

  updateOfferStatus: async (offerId: string, status: OfferStatus) => {
    try {
      await offerService.updateStatus(offerId, status);
      
      // ä¹è§‚æ›´æ–°
      set(state => ({
        offers: state.offers.map(offer =>
          offer.id === offerId ? { ...offer, status } : offer
        )
      }));
      
      // è§¦å‘çŠ¶æ€å˜æ›´åŠ¨ç”»
      triggerStatusChangeAnimation(offerId, status);
    } catch (error) {
      set({ error: error.message });
    }
  },

  // ... å…¶ä»–actions
}));
```

#### 2. å®æ—¶æ•°æ®åŒæ­¥

```typescript
// hooks/useRealtimeOffers.ts
export function useRealtimeOffers(userId: string) {
  const { offers, setOffers } = useOfferStore();
  
  useEffect(() => {
    // Firestoreå®æ—¶ç›‘å¬
    const unsubscribe = onSnapshot(
      collection(db, 'offers').where('userId', '==', userId),
      (snapshot) => {
        const updatedOffers = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        })) as Offer[];
        
        setOffers(updatedOffers);
        
        // æ£€æŸ¥çŠ¶æ€å˜æ›´å¹¶è§¦å‘åŠ¨ç”»
        snapshot.docChanges().forEach(change => {
          if (change.type === 'modified') {
            const offer = change.doc.data() as Offer;
            triggerOfferUpdateAnimation(offer.id);
          }
        });
      }
    );
    
    return unsubscribe;
  }, [userId]);
  
  return offers;
}
```

### ä¸Šç˜¾ä½“éªŒå®ç°

#### 1. å³æ—¶åé¦ˆç³»ç»Ÿ

```typescript
// lib/feedback.ts
export class FeedbackSystem {
  static showSuccess(message: string, data?: any) {
    // æˆåŠŸåŠ¨ç”»
    toast.success(message, {
      icon: 'ğŸ‰',
      duration: 3000,
      style: {
        background: '#10B981',
        color: 'white',
      }
    });
    
    // æˆåŠŸéŸ³æ•ˆ
    if (data?.playSound) {
      playSound('/sounds/success.mp3');
    }
    
    // ç²’å­æ•ˆæœ
    if (data?.showParticles) {
      triggerParticleEffect();
    }
  }
  
  static showProgress(progress: number, message: string) {
    // è¿›åº¦æ¡åŠ¨ç”»
    updateProgressBar(progress, message);
    
    // é˜¶æ®µæ€§åé¦ˆ
    if (progress === 25) {
      showMilestone('URLè§£æå®Œæˆ');
    } else if (progress === 50) {
      showMilestone('æ•°æ®åˆ†æä¸­');
    } else if (progress === 75) {
      showMilestone('ç”Ÿæˆè¯„åˆ†');
    }
  }
}
```

#### 2. æ‹–æ‹½äº¤äº’å®ç°

```typescript
// components/offers/DraggableOfferCard.tsx
export function DraggableOfferCard({ offer }: { offer: Offer }) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useDraggable({
    id: offer.id,
  });

  const style = {
    transform: CSS.Translate.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      {...listeners}
      {...attributes}
      className={`offer-card ${getStatusColor(offer.status)} ${
        isDragging ? 'dragging' : ''
      }`}
    >
      <OfferCardContent offer={offer} />
      
      {/* æ‹–æ‹½æ—¶çš„è§†è§‰åé¦ˆ */}
      {isDragging && (
        <div className="drag-overlay">
          <ArrowIcon className="animate-bounce" />
        </div>
      )}
    </div>
  );
}
```

#### 3. æ•°æ®å¯è§†åŒ–ç»„ä»¶

```typescript
// components/charts/ROSCTrendChart.tsx
export function ROSCTrendChart({ data }: { data: TrendData[] }) {
  const chartRef = useRef<Chart | null>(null);
  
  useEffect(() => {
    // åŠ¨ç”»é…ç½®
    const config = {
      type: 'line',
      data: {
        labels: data.map(d => d.date),
        datasets: [{
          label: 'ROSC',
          data: data.map(d => d.rosc),
          borderColor: '#10B981',
          backgroundColor: 'rgba(16, 185, 129, 0.1)',
          tension: 0.4,
          pointRadius: 6,
          pointHoverRadius: 8,
        }]
      },
      options: {
        responsive: true,
        animation: {
          duration: 2000,
          easing: 'easeInOutQuart'
        },
        plugins: {
          tooltip: {
            callbacks: {
              label: (context) => {
                const value = context.parsed.y;
                const color = value > 2 ? 'ğŸŸ¢' : value > 1 ? 'ğŸŸ¡' : 'ğŸ”´';
                return `${color} ROSC: ${value.toFixed(2)}`;
              }
            }
          }
        }
      }
    };
    
    chartRef.current = new Chart(canvasRef.current, config);
    
    return () => chartRef.current?.destroy();
  }, [data]);
  
  return <canvas ref={canvasRef} />;
}
```

## å®‰å…¨æ€§è®¾è®¡

### 1. è®¤è¯ä¸æˆæƒ

```typescript
// lib/auth.ts
export class AuthService {
  // Firebase Authenticationé›†æˆ
  static async signInWithGoogle(): Promise<User> {
    const provider = new GoogleAuthProvider();
    const result = await signInWithPopup(auth, provider);
    
    // åˆ›å»ºç”¨æˆ·ä¼šè¯
    await this.createUserSession(result.user);
    
    return result.user;
  }
  
  // JWT TokenéªŒè¯
  static async verifyToken(token: string): Promise<DecodedToken> {
    try {
      const decodedToken = await admin.auth().verifyIdToken(token);
      return decodedToken;
    } catch (error) {
      throw new AuthError('Invalid token');
    }
  }
  
  // æƒé™æ£€æŸ¥
  static async checkPermission(userId: string, action: string): Promise<boolean> {
    const user = await getUserSubscription(userId);
    return hasPermission(user.plan, action);
  }
}

// middleware/auth.ts
export async function authMiddleware(req: NextRequest) {
  const token = req.headers.get('authorization')?.replace('Bearer ', '');
  
  if (!token) {
    return new Response('Unauthorized', { status: 401 });
  }
  
  try {
    const decodedToken = await AuthService.verifyToken(token);
    req.user = decodedToken;
    return NextResponse.next();
  } catch (error) {
    return new Response('Invalid token', { status: 401 });
  }
}
```

### 2. æ•°æ®åŠ å¯†

```go
// internal/security/encryption.go
package security

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "encoding/base64"
    "io"
)

type EncryptionService struct {
    gcm cipher.AEAD
}

func NewEncryptionService(key []byte) (*EncryptionService, error) {
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }
    
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }
    
    return &EncryptionService{gcm: gcm}, nil
}

func (e *EncryptionService) Encrypt(plaintext string) (string, error) {
    nonce := make([]byte, e.gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return "", err
    }
    
    ciphertext := e.gcm.Seal(nonce, nonce, []byte(plaintext), nil)
    return base64.StdEncoding.EncodeToString(ciphertext), nil
}

func (e *EncryptionService) Decrypt(ciphertext string) (string, error) {
    data, err := base64.StdEncoding.DecodeString(ciphertext)
    if err != nil {
        return "", err
    }
    
    nonceSize := e.gcm.NonceSize()
    nonce, ciphertext := data[:nonceSize], data[nonceSize:]
    
    plaintext, err := e.gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return "", err
    }
    
    return string(plaintext), nil
}
```

### 3. APIå®‰å…¨

```go
// internal/middleware/security.go
func SecurityMiddleware() gin.HandlerFunc {
    return gin.HandlerFunc(func(c *gin.Context) {
        // CORSè®¾ç½®
        c.Header("Access-Control-Allow-Origin", getAllowedOrigins())
        c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization")
        
        // å®‰å…¨å¤´è®¾ç½®
        c.Header("X-Content-Type-Options", "nosniff")
        c.Header("X-Frame-Options", "DENY")
        c.Header("X-XSS-Protection", "1; mode=block")
        c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
        
        // é™æµ
        if !rateLimiter.Allow(c.ClientIP()) {
            c.JSON(429, gin.H{"error": "Rate limit exceeded"})
            c.Abort()
            return
        }
        
        c.Next()
    })
}

// APIå¯†é’¥éªŒè¯
func APIKeyMiddleware() gin.HandlerFunc {
    return gin.HandlerFunc(func(c *gin.Context) {
        apiKey := c.GetHeader("X-API-Key")
        if apiKey == "" {
            c.JSON(401, gin.H{"error": "API key required"})
            c.Abort()
            return
        }
        
        if !validateAPIKey(apiKey) {
            c.JSON(401, gin.H{"error": "Invalid API key"})
            c.Abort()
            return
        }
        
        c.Next()
    })
}
```

## æ€§èƒ½ä¼˜åŒ–è®¾è®¡

### 1. ç¼“å­˜ç­–ç•¥

```go
// internal/cache/redis.go
type CacheService struct {
    client *redis.Client
}

func (c *CacheService) GetOfferEvaluation(url string) (*EvaluationResult, error) {
    key := fmt.Sprintf("evaluation:%s", hashURL(url))
    
    cached, err := c.client.Get(context.Background(), key).Result()
    if err == redis.Nil {
        return nil, nil // ç¼“å­˜æœªå‘½ä¸­
    } else if err != nil {
        return nil, err
    }
    
    var result EvaluationResult
    if err := json.Unmarshal([]byte(cached), &result); err != nil {
        return nil, err
    }
    
    return &result, nil
}

func (c *CacheService) SetOfferEvaluation(url string, result *EvaluationResult, ttl time.Duration) error {
    key := fmt.Sprintf("evaluation:%s", hashURL(url))
    
    data, err := json.Marshal(result)
    if err != nil {
        return err
    }
    
    return c.client.Set(context.Background(), key, data, ttl).Err()
}
```

### 2. æ•°æ®åº“ä¼˜åŒ–

```sql
-- ç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_offers_user_status ON offers(user_id, status);
CREATE INDEX idx_performance_offer_date ON ads_performance_history(offer_id, date DESC);
CREATE INDEX idx_logs_user_created ON operation_logs(user_id, created_at DESC);

-- åˆ†åŒºè¡¨ï¼ˆæŒ‰æœˆåˆ†åŒºï¼‰
CREATE TABLE ads_performance_history_202401 PARTITION OF ads_performance_history
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- æŸ¥è¯¢ä¼˜åŒ–
EXPLAIN ANALYZE 
SELECT offer_id, SUM(cost_micros) as total_cost, SUM(conversions) as total_conversions
FROM ads_performance_history 
WHERE date >= '2024-01-01' AND date < '2024-02-01'
GROUP BY offer_id;
```

### 3. å‰ç«¯æ€§èƒ½ä¼˜åŒ–

```typescript
// ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½
const OfferEvaluator = lazy(() => import('../components/evaluation/OfferEvaluator'));
const BulkOperations = lazy(() => import('../components/operations/BulkOperations'));

// è™šæ‹Ÿæ»šåŠ¨ï¼ˆå¤§æ•°æ®åˆ—è¡¨ï¼‰
import { FixedSizeList as List } from 'react-window';

function CampaignList({ campaigns }: { campaigns: Campaign[] }) {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => (
    <div style={style}>
      <CampaignRow campaign={campaigns[index]} />
    </div>
  );

  return (
    <List
      height={600}
      itemCount={campaigns.length}
      itemSize={80}
      width="100%"
    >
      {Row}
    </List>
  );
}

// æ•°æ®é¢„åŠ è½½
function useOfferPreloader() {
  const queryClient = useQueryClient();
  
  const preloadOffer = useCallback((offerId: string) => {
    queryClient.prefetchQuery({
      queryKey: ['offer', offerId],
      queryFn: () => offerService.getOffer(offerId),
      staleTime: 5 * 60 * 1000, // 5åˆ†é’Ÿ
    });
  }, [queryClient]);
  
  return { preloadOffer };
}
```

## é”™è¯¯å¤„ç†ä¸ç›‘æ§

### 1. é”™è¯¯å¤„ç†ç­–ç•¥

```go
// internal/errors/errors.go
type AppError struct {
    Code    string `json:"code"`
    Message string `json:"message"`
    Details string `json:"details,omitempty"`
    TraceID string `json:"trace_id"`
}

func (e *AppError) Error() string {
    return fmt.Sprintf("[%s] %s: %s", e.Code, e.Message, e.Details)
}

// é”™è¯¯ç±»å‹å®šä¹‰
var (
    ErrOfferNotFound     = &AppError{Code: "OFFER_NOT_FOUND", Message: "Offer not found"}
    ErrInvalidURL        = &AppError{Code: "INVALID_URL", Message: "Invalid offer URL"}
    ErrEvaluationFailed  = &AppError{Code: "EVALUATION_FAILED", Message: "Offer evaluation failed"}
    ErrInsufficientPerm  = &AppError{Code: "INSUFFICIENT_PERMISSION", Message: "Insufficient permission"}
    ErrRateLimitExceeded = &AppError{Code: "RATE_LIMIT_EXCEEDED", Message: "Rate limit exceeded"}
)

// é”™è¯¯å¤„ç†ä¸­é—´ä»¶
func ErrorHandlerMiddleware() gin.HandlerFunc {
    return gin.HandlerFunc(func(c *gin.Context) {
        c.Next()
        
        if len(c.Errors) > 0 {
            err := c.Errors.Last().Err
            
            var appErr *AppError
            if errors.As(err, &appErr) {
                c.JSON(getHTTPStatus(appErr.Code), appErr)
            } else {
                // æœªçŸ¥é”™è¯¯
                traceID := generateTraceID()
                logError(err, traceID)
                
                c.JSON(500, &AppError{
                    Code:    "INTERNAL_ERROR",
                    Message: "Internal server error",
                    TraceID: traceID,
                })
            }
        }
    })
}
```

### 2. Firebase AI Logicé›†æˆè®¾è®¡

```go
// internal/ai/firebase_ai.go
type FirebaseAIService struct {
    client *genai.Client
}

// å†…å®¹åˆ†æ
func (ai *FirebaseAIService) AnalyzeContent(content string) (*ContentAnalysis, error) {
    prompt := fmt.Sprintf(`
    åˆ†æä»¥ä¸‹ç½‘é¡µå†…å®¹ï¼Œæå–å…³é”®ä¿¡æ¯ï¼š
    1. äº§å“ç±»å‹å’Œè¡Œä¸šåˆ†ç±»
    2. ç›®æ ‡å®¢ç¾¤ç‰¹å¾  
    3. é¢„ä¼°å®¢å•ä»·èŒƒå›´
    4. å­£èŠ‚æ€§ç‰¹å¾
    5. åˆè§„é£é™©è¯„ä¼°
    
    ç½‘é¡µå†…å®¹ï¼š%s
    
    è¯·ä»¥JSONæ ¼å¼è¿”å›ç»“æœã€‚
    `, content)
    
    response, err := ai.client.GenerateContent(context.Background(), prompt)
    if err != nil {
        return nil, err
    }
    
    var analysis ContentAnalysis
    if err := json.Unmarshal([]byte(response.Text), &analysis); err != nil {
        return nil, err
    }
    
    return &analysis, nil
}

// ä¼˜åŒ–å»ºè®®ç”Ÿæˆ
func (ai *FirebaseAIService) GenerateOptimizationSuggestions(offerData *Offer, performanceHistory []*PerformanceData) (*OptimizationSuggestions, error) {
    prompt := fmt.Sprintf(`
    åŸºäºä»¥ä¸‹æ•°æ®ï¼Œæä¾›3ä¸ªå…·ä½“çš„ä¼˜åŒ–å»ºè®®ï¼š
    Offeræ•°æ®ï¼š%s
    æ€§èƒ½å†å²ï¼š%s
    
    è¯·æä¾›ï¼š
    1. é—®é¢˜è¯Šæ–­
    2. å…·ä½“ä¼˜åŒ–æ–¹æ¡ˆ
    3. é¢„æœŸæ•ˆæœ
    
    ä»¥JSONæ ¼å¼è¿”å›ã€‚
    `, toJSON(offerData), toJSON(performanceHistory))
    
    response, err := ai.client.GenerateContent(context.Background(), prompt)
    if err != nil {
        return nil, err
    }
    
    var suggestions OptimizationSuggestions
    if err := json.Unmarshal([]byte(response.Text), &suggestions); err != nil {
        return nil, err
    }
    
    return &suggestions, nil
}

// åˆè§„æ€§æ£€æŸ¥
func (ai *FirebaseAIService) CheckCompliance(adContent, landingPageContent string) (*ComplianceCheck, error) {
    prompt := fmt.Sprintf(`
    æ£€æŸ¥ä»¥ä¸‹å¹¿å‘Šå†…å®¹å’Œè½åœ°é¡µçš„åˆè§„æ€§ï¼š
    å¹¿å‘Šå†…å®¹ï¼š%s
    è½åœ°é¡µå†…å®¹ï¼š%s
    
    æ£€æŸ¥é¡¹ç›®ï¼š
    1. æ˜¯å¦æ¶‰åŠè¿ç¦äº§å“ï¼ˆè¯å“ã€çƒŸè‰ã€èµŒåšç­‰ï¼‰
    2. è™šå‡å®£ä¼ é£é™©
    3. å¹´é¾„é™åˆ¶å†…å®¹
    4. åœ°åŸŸé™åˆ¶
    
    è¿”å›é£é™©ç­‰çº§å’Œå…·ä½“é—®é¢˜ã€‚
    `, adContent, landingPageContent)
    
    response, err := ai.client.GenerateContent(context.Background(), prompt)
    if err != nil {
        return nil, err
    }
    
    var compliance ComplianceCheck
    if err := json.Unmarshal([]byte(response.Text), &compliance); err != nil {
        return nil, err
    }
    
    return &compliance, nil
}
```

### 3. å¤šç”¨æˆ·æ•°æ®éš”ç¦»è®¾è®¡

```go
// internal/middleware/isolation.go
func DataIsolationMiddleware() gin.HandlerFunc {
    return gin.HandlerFunc(func(c *gin.Context) {
        userID := getUserIDFromToken(c.GetHeader("Authorization"))
        if userID == "" {
            c.JSON(401, gin.H{"error": "Unauthorized"})
            c.Abort()
            return
        }
        
        // å°†ç”¨æˆ·IDæ³¨å…¥åˆ°ä¸Šä¸‹æ–‡ä¸­
        c.Set("user_id", userID)
        c.Next()
    })
}

// æ•°æ®è®¿é—®å±‚å¼ºåˆ¶éš”ç¦»
type OfferRepository struct {
    db *sql.DB
}

func (r *OfferRepository) GetOffersByUserID(userID string) ([]*Offer, error) {
    query := `
        SELECT id, url, status, created_at, updated_at 
        FROM offers 
        WHERE user_id = ? 
        ORDER BY created_at DESC
    `
    
    rows, err := r.db.Query(query, userID)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var offers []*Offer
    for rows.Next() {
        var offer Offer
        if err := rows.Scan(&offer.ID, &offer.URL, &offer.Status, &offer.CreatedAt, &offer.UpdatedAt); err != nil {
            return nil, err
        }
        offer.UserID = userID // ç¡®ä¿ç”¨æˆ·IDæ­£ç¡®
        offers = append(offers, &offer)
    }
    
    return offers, nil
}

// Firestoreå®‰å…¨è§„åˆ™
/*
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // ç”¨æˆ·åªèƒ½è®¿é—®è‡ªå·±çš„Offeræ•°æ®
    match /offers/{offerId} {
      allow read, write: if request.auth != null && 
        request.auth.uid == resource.data.userId;
    }
    
    // ç”¨æˆ·åªèƒ½è®¿é—®è‡ªå·±çš„é€šçŸ¥
    match /users/{userId}/notifications/{notificationId} {
      allow read, write: if request.auth != null && 
        request.auth.uid == userId;
    }
    
    // ç³»ç»Ÿé…ç½®åªæœ‰ç®¡ç†å‘˜å¯ä»¥ä¿®æ”¹
    match /configs/{configId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && 
        request.auth.token.admin == true;
    }
  }
}
*/
```

### 4. æµ‹è¯•ç­–ç•¥è®¾è®¡

#### å•å…ƒæµ‹è¯•

```go
// internal/services/offer_service_test.go
func TestOfferService_CreateOffer(t *testing.T) {
    tests := []struct {
        name    string
        request *CreateOfferRequest
        want    *Offer
        wantErr bool
    }{
        {
            name: "valid offer creation",
            request: &CreateOfferRequest{
                URL:     "https://example.com/offer",
                Country: "US",
                UserID:  "user123",
            },
            want: &Offer{
                URL:     "https://example.com/offer",
                Country: "US",
                Status:  "pool",
                UserID:  "user123",
            },
            wantErr: false,
        },
        {
            name: "invalid URL",
            request: &CreateOfferRequest{
                URL:     "invalid-url",
                Country: "US",
                UserID:  "user123",
            },
            want:    nil,
            wantErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            service := NewOfferService(mockRepo, mockValidator)
            got, err := service.CreateOffer(context.Background(), tt.request)
            
            if (err != nil) != tt.wantErr {
                t.Errorf("CreateOffer() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            
            if !tt.wantErr && !reflect.DeepEqual(got.URL, tt.want.URL) {
                t.Errorf("CreateOffer() = %v, want %v", got, tt.want)
            }
        })
    }
}

// æ€§èƒ½æµ‹è¯•
func BenchmarkOfferService_GetOffers(b *testing.B) {
    service := NewOfferService(mockRepo, mockValidator)
    userID := "user123"
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _, err := service.GetOffers(context.Background(), userID)
        if err != nil {
            b.Fatal(err)
        }
    }
}
```

#### ç«¯åˆ°ç«¯æµ‹è¯•

```typescript
// e2e/offer-management.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Offer Management Flow', () => {
  test('complete offer lifecycle', async ({ page }) => {
    // 1. ç™»å½•
    await page.goto('/login');
    await page.fill('[data-testid=email]', 'test@example.com');
    await page.fill('[data-testid=password]', 'password');
    await page.click('[data-testid=login-button]');
    
    // 2. åˆ›å»ºOffer
    await page.goto('/offers');
    await page.click('[data-testid=create-offer]');
    await page.fill('[data-testid=offer-url]', 'https://example.com/test-offer');
    await page.selectOption('[data-testid=country]', 'US');
    await page.click('[data-testid=submit]');
    
    // 3. éªŒè¯Offerå‡ºç°åœ¨æœºä¼šæ± 
    await expect(page.locator('[data-testid=offer-card]')).toBeVisible();
    await expect(page.locator('[data-testid=offer-status]')).toHaveText('æœºä¼šæ± ');
    
    // 4. è¯„ä¼°Offer
    await page.click('[data-testid=evaluate-offer]');
    await expect(page.locator('[data-testid=evaluation-progress]')).toBeVisible();
    
    // 5. ç­‰å¾…è¯„ä¼°å®Œæˆ
    await page.waitForSelector('[data-testid=evaluation-score]', { timeout: 15000 });
    const score = await page.textContent('[data-testid=evaluation-score]');
    expect(parseInt(score)).toBeGreaterThan(0);
    
    // 6. æ‹–æ‹½åˆ°ä»¿çœŸé˜¶æ®µ
    await page.dragAndDrop('[data-testid=offer-card]', '[data-testid=simulation-column]');
    await expect(page.locator('[data-testid=offer-status]')).toHaveText('ä»¿çœŸä¸­');
  });

  test('bulk operations', async ({ page }) => {
    await page.goto('/operations');
    
    // é€‰æ‹©å¤šä¸ªOffer
    await page.check('[data-testid=offer-checkbox-1]');
    await page.check('[data-testid=offer-checkbox-2]');
    
    // æ‰§è¡Œæ‰¹é‡æ“ä½œ
    await page.selectOption('[data-testid=bulk-operation]', 'adjust-cpc');
    await page.fill('[data-testid=cpc-value]', '1.50');
    await page.click('[data-testid=preview-operation]');
    
    // ç¡®è®¤é¢„è§ˆ
    await expect(page.locator('[data-testid=affected-count]')).toHaveText('2ä¸ªOffer');
    await page.click('[data-testid=confirm-operation]');
    
    // éªŒè¯æ“ä½œç»“æœ
    await expect(page.locator('[data-testid=operation-success]')).toBeVisible();
  });
});
```

#### æ€§èƒ½æµ‹è¯•

```yaml
# k6/load-test.js
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  stages: [
    { duration: '2m', target: 100 }, // 2åˆ†é’Ÿå†…å¢åŠ åˆ°100ç”¨æˆ·
    { duration: '5m', target: 100 }, // ä¿æŒ100ç”¨æˆ·5åˆ†é’Ÿ
    { duration: '2m', target: 200 }, // 2åˆ†é’Ÿå†…å¢åŠ åˆ°200ç”¨æˆ·
    { duration: '5m', target: 200 }, // ä¿æŒ200ç”¨æˆ·5åˆ†é’Ÿ
    { duration: '2m', target: 0 },   // 2åˆ†é’Ÿå†…é™åˆ°0ç”¨æˆ·
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'], // 95%çš„è¯·æ±‚åœ¨500mså†…å®Œæˆ
    http_req_failed: ['rate<0.1'],    // é”™è¯¯ç‡ä½äº10%
  },
};

export default function () {
  // æµ‹è¯•è·å–Offeråˆ—è¡¨
  let response = http.get('https://api.autoads.dev/api/v1/offers', {
    headers: {
      'Authorization': 'Bearer ' + __ENV.API_TOKEN,
    },
  });
  
  check(response, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
    'offers returned': (r) => JSON.parse(r.body).length > 0,
  });
  
  sleep(1);
}
```

### 5. åŠ¨æ€é…ç½®ç®¡ç†è®¾è®¡

#### é…ç½®çƒ­æ›´æ–°æ¶æ„

```go
// internal/config/manager.go
type ConfigManager struct {
    client    *firestore.Client
    cache     map[string]interface{}
    listeners map[string][]ConfigListener
    mutex     sync.RWMutex
}

type ConfigListener interface {
    OnConfigChange(key string, value interface{})
}

func (cm *ConfigManager) StartWatching() {
    // ç›‘å¬Firestoreé…ç½®å˜æ›´
    iter := cm.client.Collection("configs").Snapshots(context.Background())
    
    go func() {
        for {
            snap, err := iter.Next()
            if err != nil {
                log.Printf("Config watch error: %v", err)
                continue
            }
            
            for _, change := range snap.Changes {
                switch change.Kind {
                case firestore.DocumentAdded, firestore.DocumentModified:
                    cm.handleConfigChange(change.Doc)
                }
            }
        }
    }()
}

func (cm *ConfigManager) handleConfigChange(doc *firestore.DocumentSnapshot) {
    cm.mutex.Lock()
    defer cm.mutex.Unlock()
    
    configKey := doc.Ref.ID
    configValue := doc.Data()
    
    // æ›´æ–°ç¼“å­˜
    cm.cache[configKey] = configValue
    
    // é€šçŸ¥ç›‘å¬è€…
    if listeners, exists := cm.listeners[configKey]; exists {
        for _, listener := range listeners {
            go listener.OnConfigChange(configKey, configValue)
        }
    }
    
    log.Printf("Config updated: %s", configKey)
}

// è¯„ä¼°æ ‡å‡†é…ç½®ç›‘å¬å™¨
type EvaluationConfigListener struct {
    evaluationService *EvaluationService
}

func (ecl *EvaluationConfigListener) OnConfigChange(key string, value interface{}) {
    if key == "evaluation_standards" {
        standards := value.(map[string]interface{})
        ecl.evaluationService.UpdateStandards(standards)
        log.Printf("Evaluation standards updated")
    }
}
```

#### Firestoreé…ç½®ç»“æ„æ‰©å±•

```javascript
// /configs/dynamic_settings
{
  evaluation: {
    standards: {
      trafficPotential: {
        weights: { volume: 0.4, growth: 0.3, competition: 0.3 },
        thresholds: { high: 100000, medium: 10000, low: 1000 }
      },
      keywordRelevance: {
        weights: { match: 0.5, intent: 0.3, competition: 0.2 },
        thresholds: { high: 0.8, medium: 0.6, low: 0.4 }
      }
    },
    aiPrompts: {
      contentAnalysis: "åˆ†æä»¥ä¸‹ç½‘é¡µå†…å®¹...",
      complianceCheck: "æ£€æŸ¥ä»¥ä¸‹å†…å®¹çš„åˆè§„æ€§...",
      optimizationSuggestion: "åŸºäºæ•°æ®æä¾›ä¼˜åŒ–å»ºè®®..."
    }
  },
  
  riskManagement: {
    autoTriggers: {
      zeroPerformanceDays: 5,
      roscDeclineThreshold: 0.2,
      roscDeclineDays: 7,
      lowBudgetThreshold: 20
    },
    businessRisks: {
      accountSuspended: { level: "critical", actions: ["notify", "pause_all"] },
      advertiserVerification: { level: "high", actions: ["notify", "manual_review"] },
      adDisapproved: { level: "medium", actions: ["notify", "suggest_fix"] },
      adLimited: { level: "medium", actions: ["notify", "analyze_cause"] },
      lowBudget: { level: "low", actions: ["notify", "suggest_recharge"] }
    },
    systemRisks: {
      urlParsingFailed: { level: "high", actions: ["retry", "switch_proxy", "notify"] },
      clickSimulationFailed: { level: "medium", actions: ["pause_simulation", "analyze_cause"] },
      linkRotationFailed: { level: "medium", actions: ["retry", "manual_intervention"] },
      clickPatternDeviation: { level: "low", actions: ["adjust_pattern", "notify"] }
    },
    alertLevels: {
      low: { color: "yellow", actions: ["notify"] },
      medium: { color: "orange", actions: ["notify", "suggest"] },
      high: { color: "red", actions: ["notify", "suggest", "pause"] },
      critical: { color: "red", actions: ["notify", "auto_pause"] }
    }
  },
  
  subscriptionPlans: {
    Pro: {
      name: "Proå¥—é¤",
      description: "é€‚åˆä¸ªäººç”¨æˆ·å°é²œä½¿ç”¨",
      price: { monthly: 99, yearly: 999 },
      features: ["basic_evaluation", "manual_operations"],
      limits: {
        tokenLimit: 1000,
        offerLimit: 10,
        accountLimit: 5,
        apiCallsPerDay: 1000
      },
      permissions: [
        "offer:create", "offer:evaluate", "offer:manual_operations"
      ]
    },
    Max: {
      name: "Maxå¥—é¤", 
      description: "é€‚åˆä¸“ä¸šç”¨æˆ·æ—¥å¸¸ä½¿ç”¨",
      price: { monthly: 299, yearly: 2999 },
      features: ["advanced_evaluation", "bulk_operations", "ab_testing"],
      limits: {
        tokenLimit: 5000,
        offerLimit: 50,
        accountLimit: 25,
        apiCallsPerDay: 10000
      },
      permissions: [
        "offer:*", "bulk:*", "ab_testing:*"
      ]
    },
    Elite: {
      name: "Eliteå¥—é¤",
      description: "é€‚åˆä¼ä¸šç”¨æˆ·æ·±åº¦ä½¿ç”¨", 
      price: { monthly: 999, yearly: 9999 },
      features: ["all_features", "priority_support", "custom_ai"],
      limits: {
        tokenLimit: -1,
        offerLimit: -1,
        accountLimit: -1,
        apiCallsPerDay: -1
      },
      permissions: ["*"]
    }
  },
  
  tokenConsumption: {
    rules: {
      "offer:evaluate": 10,
      "offer:simulate": 50,
      "bulk:operation": 5,
      "ai:analysis": 20,
      "url:parse": 2
    },
    multipliers: {
      "batch_operation": 0.8, // æ‰¹é‡æ“ä½œ8æŠ˜
      "premium_user": 0.5     // é«˜çº§ç”¨æˆ·5æŠ˜
    }
  },
  
  proxySettings: {
    countryAPIs: {
      "US": { url: "https://api.proxy-us.com", weight: 1 },
      "UK": { url: "https://api.proxy-uk.com", weight: 1 },
      "CA": { url: "https://api.proxy-ca.com", weight: 0.8 }
    },
    reuseWindow: 300,
    maxRetries: 3,
    timeout: 10000
  },
  
  featureFlags: {
    enableABTesting: true,
    enableAdvancedAI: true,
    enableBulkOperations: true,
    enableRealTimeSync: true,
    maintenanceMode: false
  },
  
  apiMonitoring: {
    googleAdsAPI: {
      dailyLimit: 15000,
      currentUsage: 8500,
      warningThreshold: 12000,
      criticalThreshold: 14000,
      callsPerService: {
        "data-sync": 5000,
        "bulk-operations": 2000,
        "offer-management": 1500
      }
    },
    rateLimiting: {
      enabled: true,
      strategy: "adaptive", // adaptive, fixed, burst
      maxCallsPerMinute: 25,
      burstAllowance: 50
    }
  },
  
  clickOptimization: {
    analysisEnabled: true,
    patterns: {
      workday: {
        peakHours: [9, 11, 14, 16, 20],
        distribution: "normal",
        variance: 0.2
      },
      weekend: {
        peakHours: [10, 15, 19, 21],
        distribution: "uniform",
        variance: 0.3
      }
    },
    realityScore: {
      threshold: 0.85,
      factors: ["timing", "frequency", "pattern", "geolocation"]
    }
  },
  
  updatedAt: "2024-01-15T10:30:00Z",
  updatedBy: "admin@autoads.dev",
  version: "1.2.3"
}

// /admin/dashboard_stats (å®æ—¶ç»Ÿè®¡æ•°æ®)
{
  users: {
    total: 1250,
    active: 890,
    new: 45,
    churn: 12
  },
  revenue: {
    monthly: 125000,
    daily: 4200,
    growth: 0.15
  },
  system: {
    health: "healthy",
    uptime: 0.999,
    apiCalls: 45000,
    errorRate: 0.002
  },
  offers: {
    total: 8500,
    active: 6200,
    evaluating: 1200,
    simulating: 800
  }
}

// /admin/users/{userId}/profile (ç”¨æˆ·è¯¦æƒ…)
{
  basic: {
    id: "user123",
    email: "user@example.com",
    displayName: "å¼ ä¸‰",
    createdAt: "2024-01-01T00:00:00Z",
    lastLoginAt: "2024-01-15T10:30:00Z",
    status: "active"
  },
  subscription: {
    plan: "Max",
    status: "active",
    expiresAt: "2024-12-31T23:59:59Z",
    autoRenew: true
  },
  tokens: {
    balance: 3500,
    consumed: 1500,
    rechargeHistory: [
      {
        amount: 5000,
        reason: "å¥—é¤å……å€¼",
        timestamp: "2024-01-01T00:00:00Z"
      }
    ]
  },
  usage: {
    offersCreated: 25,
    evaluationsRun: 150,
    bulkOperations: 45,
    lastActivity: "2024-01-15T09:45:00Z"
  },
  limits: {
    offers: { used: 25, limit: 50 },
    accounts: { used: 8, limit: 25 },
    apiCalls: { used: 2500, limit: 10000, resetAt: "2024-01-16T00:00:00Z" }
  }
}
```

#### åå°ç®¡ç†ç³»ç»Ÿå‰ç«¯è®¾è®¡

```typescript
// components/admin/AdminDashboard.tsx
export function AdminDashboard() {
  const { data: stats } = useQuery({
    queryKey: ['admin', 'dashboard'],
    queryFn: () => adminService.getDashboardStats(),
    refetchInterval: 30000 // 30ç§’åˆ·æ–°
  });

  return (
    <div className="admin-dashboard">
      <DashboardHeader />
      
      <div className="grid grid-cols-4 gap-6 mb-8">
        <StatCard
          title="æ€»ç”¨æˆ·æ•°"
          value={stats?.users.total}
          change={stats?.users.new}
          icon={<UsersIcon />}
        />
        <StatCard
          title="æœˆæ”¶å…¥"
          value={formatCurrency(stats?.revenue.monthly)}
          change={stats?.revenue.growth}
          icon={<RevenueIcon />}
        />
        <StatCard
          title="ç³»ç»Ÿå¥åº·åº¦"
          value={`${(stats?.system.uptime * 100).toFixed(2)}%`}
          status={stats?.system.health}
          icon={<HealthIcon />}
        />
        <StatCard
          title="æ´»è·ƒOffer"
          value={stats?.offers.active}
          total={stats?.offers.total}
          icon={<OffersIcon />}
        />
      </div>
      
      <div className="grid grid-cols-2 gap-6">
        <RevenueChart data={stats?.revenue.trends} />
        <UserActivityChart data={stats?.users.activity} />
      </div>
    </div>
  );
}

// components/admin/UserManagement.tsx
export function UserManagement() {
  const [filters, setFilters] = useState({
    plan: 'all',
    status: 'all',
    search: ''
  });
  
  const { data: users, isLoading } = useQuery({
    queryKey: ['admin', 'users', filters],
    queryFn: () => adminService.getUsers(filters)
  });

  const handleUserAction = async (userId: string, action: string, data?: any) => {
    try {
      await adminService.updateUser(userId, action, data);
      toast.success('æ“ä½œæˆåŠŸ');
      queryClient.invalidateQueries(['admin', 'users']);
    } catch (error) {
      toast.error('æ“ä½œå¤±è´¥');
    }
  };

  return (
    <div className="user-management">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">ç”¨æˆ·ç®¡ç†</h1>
        <UserFilters filters={filters} onChange={setFilters} />
      </div>
      
      <UserTable
        users={users}
        loading={isLoading}
        onAction={handleUserAction}
      />
      
      <UserDetailModal
        user={selectedUser}
        onClose={() => setSelectedUser(null)}
        onUpdate={handleUserAction}
      />
    </div>
  );
}

// components/admin/PlanManagement.tsx
export function PlanManagement() {
  const { data: plans } = useQuery({
    queryKey: ['admin', 'plans'],
    queryFn: () => adminService.getPlans()
  });

  const [editingPlan, setEditingPlan] = useState<Plan | null>(null);

  const handleSavePlan = async (planData: PlanData) => {
    try {
      if (editingPlan) {
        await adminService.updatePlan(editingPlan.id, planData);
      } else {
        await adminService.createPlan(planData);
      }
      
      toast.success('å¥—é¤ä¿å­˜æˆåŠŸ');
      queryClient.invalidateQueries(['admin', 'plans']);
      setEditingPlan(null);
    } catch (error) {
      toast.error('å¥—é¤ä¿å­˜å¤±è´¥');
    }
  };

  return (
    <div className="plan-management">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">å¥—é¤ç®¡ç†</h1>
        <button
          onClick={() => setEditingPlan({} as Plan)}
          className="btn btn-primary"
        >
          åˆ›å»ºå¥—é¤
        </button>
      </div>
      
      <div className="grid grid-cols-3 gap-6">
        {plans?.map(plan => (
          <PlanCard
            key={plan.id}
            plan={plan}
            onEdit={() => setEditingPlan(plan)}
            onDelete={() => handleDeletePlan(plan.id)}
          />
        ))}
      </div>
      
      <PlanEditor
        plan={editingPlan}
        onSave={handleSavePlan}
        onCancel={() => setEditingPlan(null)}
      />
    </div>
  );
}

// components/admin/TokenManagement.tsx
export function TokenManagement() {
  const { data: tokenStats } = useQuery({
    queryKey: ['admin', 'tokens', 'stats'],
    queryFn: () => adminService.getTokenStats()
  });

  const [consumptionRules, setConsumptionRules] = useState({});

  const handleUpdateRules = async (rules: ConsumptionRules) => {
    try {
      await adminService.updateTokenRules(rules);
      toast.success('æ¶ˆè€—è§„åˆ™æ›´æ–°æˆåŠŸ');
    } catch (error) {
      toast.error('æ›´æ–°å¤±è´¥');
    }
  };

  const handleBulkRecharge = async (rechargeData: BulkRechargeData) => {
    try {
      await adminService.bulkRecharge(rechargeData);
      toast.success('æ‰¹é‡å……å€¼æˆåŠŸ');
      queryClient.invalidateQueries(['admin', 'tokens']);
    } catch (error) {
      toast.error('æ‰¹é‡å……å€¼å¤±è´¥');
    }
  };

  return (
    <div className="token-management">
      <div className="grid grid-cols-3 gap-6 mb-8">
        <TokenStatCard
          title="æ€»æ¶ˆè€—Token"
          value={tokenStats?.totalConsumed}
          trend={tokenStats?.consumptionTrend}
        />
        <TokenStatCard
          title="å¹³å‡æ¯ç”¨æˆ·æ¶ˆè€—"
          value={tokenStats?.avgPerUser}
          comparison={tokenStats?.avgComparison}
        />
        <TokenStatCard
          title="å¼‚å¸¸æ¶ˆè€—ç”¨æˆ·"
          value={tokenStats?.abnormalUsers}
          alerts={tokenStats?.alerts}
        />
      </div>
      
      <div className="grid grid-cols-2 gap-6">
        <ConsumptionRulesEditor
          rules={consumptionRules}
          onUpdate={handleUpdateRules}
        />
        
        <BulkRechargePanel
          onRecharge={handleBulkRecharge}
        />
      </div>
      
      <TokenConsumptionChart data={tokenStats?.consumptionHistory} />
    </div>
  );
}

// components/admin/ConfigManager.tsx
export function ConfigManager() {
  const [configs, setConfigs] = useState<ConfigData>({});
  const [selectedSection, setSelectedSection] = useState('evaluation');
  const [pendingChanges, setPendingChanges] = useState({});
  
  // å®æ—¶ç›‘å¬é…ç½®å˜æ›´
  useEffect(() => {
    const unsubscribe = onSnapshot(
      doc(db, 'configs', 'dynamic_settings'),
      (doc) => {
        if (doc.exists()) {
          setConfigs(doc.data() as ConfigData);
        }
      }
    );
    
    return unsubscribe;
  }, []);
  
  const updateConfig = async (section: string, key: string, value: any) => {
    try {
      await updateDoc(doc(db, 'configs', 'dynamic_settings'), {
        [`${section}.${key}`]: value,
        updatedAt: new Date().toISOString(),
        updatedBy: user.email
      });
      
      toast.success('é…ç½®æ›´æ–°æˆåŠŸ');
      setPendingChanges({});
    } catch (error) {
      toast.error('é…ç½®æ›´æ–°å¤±è´¥');
    }
  };
  
  return (
    <div className="config-manager">
      <div className="flex h-screen">
        <ConfigSidebar 
          sections={CONFIG_SECTIONS}
          selected={selectedSection}
          onSelect={setSelectedSection}
        />
        
        <div className="flex-1 flex">
          <ConfigEditor
            section={selectedSection}
            data={configs[selectedSection]}
            onChange={(key, value) => {
              setPendingChanges(prev => ({
                ...prev,
                [`${selectedSection}.${key}`]: value
              }));
            }}
          />
          
          <ConfigPreview
            changes={pendingChanges}
            onApply={() => applyChanges(pendingChanges)}
            onRevert={() => setPendingChanges({})}
          />
        </div>
      </div>
    </div>
  );
}

// é…ç½®ç¼–è¾‘å™¨ç»„ä»¶
const CONFIG_SECTIONS = [
  { id: 'evaluation', name: 'è¯„ä¼°æ ‡å‡†', icon: <EvaluationIcon /> },
  { id: 'riskManagement', name: 'é£é™©ç®¡ç†', icon: <RiskIcon /> },
  { id: 'subscriptionPlans', name: 'å¥—é¤é…ç½®', icon: <PlansIcon /> },
  { id: 'tokenConsumption', name: 'Tokenè§„åˆ™', icon: <TokenIcon /> },
  { id: 'proxySettings', name: 'ä»£ç†è®¾ç½®', icon: <ProxyIcon /> },
  { id: 'featureFlags', name: 'åŠŸèƒ½å¼€å…³', icon: <FlagsIcon /> }
];
```
```

#### åå°ç®¡ç†æœåŠ¡å®ç°

```go
// internal/admin/dashboard_service.go
type DashboardService struct {
    userRepo    UserRepository
    offerRepo   OfferRepository
    revenueRepo RevenueRepository
    systemRepo  SystemRepository
}

func (ds *DashboardService) GetDashboardStats(ctx context.Context) (*DashboardStats, error) {
    var stats DashboardStats
    
    // å¹¶å‘è·å–å„é¡¹ç»Ÿè®¡æ•°æ®
    var wg sync.WaitGroup
    var mu sync.Mutex
    
    wg.Add(4)
    
    // ç”¨æˆ·ç»Ÿè®¡
    go func() {
        defer wg.Done()
        userStats, err := ds.userRepo.GetUserStats(ctx)
        if err == nil {
            mu.Lock()
            stats.Users = userStats
            mu.Unlock()
        }
    }()
    
    // æ”¶å…¥ç»Ÿè®¡
    go func() {
        defer wg.Done()
        revenueStats, err := ds.revenueRepo.GetRevenueStats(ctx)
        if err == nil {
            mu.Lock()
            stats.Revenue = revenueStats
            mu.Unlock()
        }
    }()
    
    // ç³»ç»Ÿç»Ÿè®¡
    go func() {
        defer wg.Done()
        systemStats, err := ds.systemRepo.GetSystemStats(ctx)
        if err == nil {
            mu.Lock()
            stats.System = systemStats
            mu.Unlock()
        }
    }()
    
    // Offerç»Ÿè®¡
    go func() {
        defer wg.Done()
        offerStats, err := ds.offerRepo.GetOfferStats(ctx)
        if err == nil {
            mu.Lock()
            stats.Offers = offerStats
            mu.Unlock()
        }
    }()
    
    wg.Wait()
    return &stats, nil
}

// internal/admin/user_service.go
type UserService struct {
    userRepo UserRepository
    tokenRepo TokenRepository
    auditRepo AuditRepository
}

func (us *UserService) GetUsers(ctx context.Context, filters UserFilters) ([]*UserSummary, error) {
    users, err := us.userRepo.GetUsersWithFilters(ctx, filters)
    if err != nil {
        return nil, err
    }
    
    // æ‰¹é‡è·å–ç”¨æˆ·çš„Tokenä½™é¢å’Œä½¿ç”¨ç»Ÿè®¡
    userIDs := make([]string, len(users))
    for i, user := range users {
        userIDs[i] = user.ID
    }
    
    tokenBalances, _ := us.tokenRepo.GetBalancesByUserIDs(ctx, userIDs)
    usageStats, _ := us.auditRepo.GetUsageStatsByUserIDs(ctx, userIDs)
    
    // ç»„è£…ç”¨æˆ·æ‘˜è¦ä¿¡æ¯
    summaries := make([]*UserSummary, len(users))
    for i, user := range users {
        summaries[i] = &UserSummary{
            User: user,
            TokenBalance: tokenBalances[user.ID],
            UsageStats: usageStats[user.ID],
        }
    }
    
    return summaries, nil
}

func (us *UserService) UpdateUserStatus(ctx context.Context, userID string, status UserStatus) error {
    // æ›´æ–°ç”¨æˆ·çŠ¶æ€
    if err := us.userRepo.UpdateStatus(ctx, userID, status); err != nil {
        return err
    }
    
    // è®°å½•æ“ä½œæ—¥å¿—
    audit := &AuditLog{
        UserID: userID,
        Action: "status_change",
        Details: map[string]interface{}{
            "new_status": status,
        },
        Timestamp: time.Now(),
    }
    
    return us.auditRepo.CreateAuditLog(ctx, audit)
}

// internal/admin/plan_service.go
type PlanService struct {
    configManager *ConfigManager
    userRepo      UserRepository
}

func (ps *PlanService) CreatePlan(ctx context.Context, planData *PlanData) error {
    // éªŒè¯å¥—é¤æ•°æ®
    if err := ps.validatePlanData(planData); err != nil {
        return err
    }
    
    // æ›´æ–°Firestoreé…ç½®
    planConfig := map[string]interface{}{
        fmt.Sprintf("subscriptionPlans.%s", planData.ID): planData,
        "updatedAt": time.Now().UTC(),
        "updatedBy": getUserEmail(ctx),
    }
    
    return ps.configManager.UpdateConfig(ctx, planConfig)
}

func (ps *PlanService) GetPlanUsers(ctx context.Context, planID string) ([]*User, error) {
    return ps.userRepo.GetUsersByPlan(ctx, planID)
}

// internal/admin/token_service.go
type TokenService struct {
    tokenRepo     TokenRepository
    configManager *ConfigManager
    userRepo      UserRepository
}

func (ts *TokenService) GetTokenStats(ctx context.Context) (*TokenStats, error) {
    stats := &TokenStats{}
    
    // è·å–æ€»æ¶ˆè€—ç»Ÿè®¡
    totalConsumed, err := ts.tokenRepo.GetTotalConsumed(ctx)
    if err != nil {
        return nil, err
    }
    stats.TotalConsumed = totalConsumed
    
    // è·å–å¹³å‡æ¶ˆè€—
    avgPerUser, err := ts.tokenRepo.GetAverageConsumptionPerUser(ctx)
    if err != nil {
        return nil, err
    }
    stats.AvgPerUser = avgPerUser
    
    // æ£€æµ‹å¼‚å¸¸æ¶ˆè€—ç”¨æˆ·
    abnormalUsers, err := ts.detectAbnormalConsumption(ctx)
    if err != nil {
        return nil, err
    }
    stats.AbnormalUsers = len(abnormalUsers)
    
    return stats, nil
}

func (ts *TokenService) BulkRecharge(ctx context.Context, rechargeData *BulkRechargeData) error {
    // æ‰¹é‡å……å€¼Token
    for _, userID := range rechargeData.UserIDs {
        if err := ts.tokenRepo.AddTokens(ctx, userID, rechargeData.Amount); err != nil {
            log.Printf("Failed to recharge tokens for user %s: %v", userID, err)
            continue
        }
        
        // è®°å½•å……å€¼å†å²
        rechargeRecord := &TokenRecharge{
            UserID: userID,
            Amount: rechargeData.Amount,
            Reason: rechargeData.Reason,
            AdminID: getUserID(ctx),
            Timestamp: time.Now(),
        }
        
        ts.tokenRepo.RecordRecharge(ctx, rechargeRecord)
    }
    
    return nil
}

func (ts *TokenService) UpdateConsumptionRules(ctx context.Context, rules *ConsumptionRules) error {
    configUpdate := map[string]interface{}{
        "tokenConsumption.rules": rules.Rules,
        "tokenConsumption.multipliers": rules.Multipliers,
        "updatedAt": time.Now().UTC(),
        "updatedBy": getUserEmail(ctx),
    }
    
    return ts.configManager.UpdateConfig(ctx, configUpdate)
}

// internal/admin/api_monitor_service.go
type APIMonitorService struct {
    metricsRepo   MetricsRepository
    configManager *ConfigManager
    alertService  *AlertService
}

func (ams *APIMonitorService) GetAPIStats(ctx context.Context) (*APIStats, error) {
    stats := &APIStats{}
    
    // è·å–Google Ads APIè°ƒç”¨ç»Ÿè®¡
    dailyUsage, err := ams.metricsRepo.GetDailyAPIUsage(ctx, "google_ads")
    if err != nil {
        return nil, err
    }
    
    stats.GoogleAdsAPI = &GoogleAdsAPIStats{
        DailyUsage:    dailyUsage.Total,
        DailyLimit:    15000,
        UsagePercent:  float64(dailyUsage.Total) / 15000.0,
        CallsByService: dailyUsage.ByService,
    }
    
    // æ£€æŸ¥æ˜¯å¦æ¥è¿‘é™åˆ¶
    if dailyUsage.Total > 12000 {
        ams.alertService.SendAlert(ctx, &Alert{
            Type:    "api_quota_warning",
            Message: fmt.Sprintf("Google Ads API usage: %d/15000", dailyUsage.Total),
            Level:   "warning",
        })
    }
    
    return stats, nil
}

func (ams *APIMonitorService) UpdateRateLimit(ctx context.Context, limits *RateLimitConfig) error {
    configUpdate := map[string]interface{}{
        "apiMonitoring.rateLimiting": limits,
        "updatedAt": time.Now().UTC(),
        "updatedBy": getUserEmail(ctx),
    }
    
    return ams.configManager.UpdateConfig(ctx, configUpdate)
}

// internal/admin/click_analysis_service.go
type ClickAnalysisService struct {
    clickRepo     ClickRepository
    aiService     *FirebaseAIService
    configManager *ConfigManager
    urlParserAPI  URLParserAPIClient
}

func (cas *ClickAnalysisService) AnalyzeClickReality(ctx context.Context, offerID string) (*ClickAnalysisResult, error) {
    // è·å–ç‚¹å‡»æ•°æ®
    clickData, err := cas.clickRepo.GetClickData(ctx, offerID)
    if err != nil {
        return nil, err
    }
    
    // ä½¿ç”¨Firebase AIåˆ†æç‚¹å‡»æ¨¡å¼
    prompt := fmt.Sprintf(`
    åˆ†æä»¥ä¸‹ç‚¹å‡»æ•°æ®çš„çœŸå®æ€§ï¼š
    ç‚¹å‡»æ—¶é—´åˆ†å¸ƒï¼š%s
    ç‚¹å‡»é¢‘ç‡ï¼š%s
    åœ°ç†ä½ç½®åˆ†å¸ƒï¼š%s
    
    è¯·è¯„ä¼°ï¼š
    1. çœŸå®æ€§è¯„åˆ† (0-1)
    2. å¼‚å¸¸æ¨¡å¼è¯†åˆ«
    3. ä¼˜åŒ–å»ºè®®
    `, 
        toJSON(clickData.TimeDistribution),
        toJSON(clickData.Frequency),
        toJSON(clickData.GeoDistribution),
    )
    
    aiResult, err := cas.aiService.AnalyzeContent(prompt)
    if err != nil {
        return nil, err
    }
    
    result := &ClickAnalysisResult{
        OfferID:      offerID,
        RealityScore: aiResult.RealityScore,
        Anomalies:    aiResult.Anomalies,
        Suggestions:  aiResult.Suggestions,
        AnalyzedAt:   time.Now(),
    }
    
    return result, nil
}

func (cas *ClickAnalysisService) OptimizeClickStrategy(ctx context.Context, analysisResult *ClickAnalysisResult) (*OptimizedStrategy, error) {
    // åŸºäºåˆ†æç»“æœç”Ÿæˆä¼˜åŒ–ç­–ç•¥
    strategy := &OptimizedStrategy{
        OfferID: analysisResult.OfferID,
        Patterns: make(map[string]interface{}),
    }
    
    // æ ¹æ®AIå»ºè®®è°ƒæ•´ç‚¹å‡»æ¨¡å¼
    for _, suggestion := range analysisResult.Suggestions {
        switch suggestion.Type {
        case "timing_adjustment":
            strategy.Patterns["timing"] = suggestion.Value
        case "frequency_adjustment":
            strategy.Patterns["frequency"] = suggestion.Value
        case "geo_distribution":
            strategy.Patterns["geo"] = suggestion.Value
        }
    }
    
    return strategy, nil
}

func (cas *ClickAnalysisService) DeployStrategy(ctx context.Context, strategy *OptimizedStrategy) error {
    // å°†ä¼˜åŒ–ç­–ç•¥æ¨é€åˆ°URLè§£ææœåŠ¡
    deployRequest := &StrategyDeployRequest{
        OfferID:  strategy.OfferID,
        Patterns: strategy.Patterns,
        Version:  time.Now().Unix(),
    }
    
    return cas.urlParserAPI.UpdateClickStrategy(ctx, deployRequest)
}
```

### 7. ç›‘æ§å’Œæ—¥å¿—

```go
// internal/monitoring/logger.go
type Logger struct {
    logger *logrus.Logger
}

func NewLogger() *Logger {
    logger := logrus.New()
    logger.SetFormatter(&logrus.JSONFormatter{})
    logger.SetLevel(logrus.InfoLevel)
    
    return &Logger{logger: logger}
}

func (l *Logger) LogOperation(ctx context.Context, operation string, data interface{}) {
    l.logger.WithFields(logrus.Fields{
        "operation": operation,
        "user_id":   getUserID(ctx),
        "trace_id":  getTraceID(ctx),
        "data":      data,
        "timestamp": time.Now().UTC(),
    }).Info("Operation executed")
}

func (l *Logger) LogError(ctx context.Context, err error, details map[string]interface{}) {
    l.logger.WithFields(logrus.Fields{
        "error":     err.Error(),
        "user_id":   getUserID(ctx),
        "trace_id":  getTraceID(ctx),
        "details":   details,
        "timestamp": time.Now().UTC(),
    }).Error("Error occurred")
}

// æ€§èƒ½ç›‘æ§
func (l *Logger) LogPerformance(ctx context.Context, operation string, duration time.Duration) {
    l.logger.WithFields(logrus.Fields{
        "operation": operation,
        "duration":  duration.Milliseconds(),
        "user_id":   getUserID(ctx),
        "trace_id":  getTraceID(ctx),
    }).Info("Performance metric")
}
```

### 3. å¥åº·æ£€æŸ¥

```go
// internal/health/checker.go
type HealthChecker struct {
    checks map[string]HealthCheck
}

type HealthCheck interface {
    Check(ctx context.Context) error
    Name() string
}

type DatabaseHealthCheck struct {
    db *sql.DB
}

func (d *DatabaseHealthCheck) Check(ctx context.Context) error {
    return d.db.PingContext(ctx)
}

func (d *DatabaseHealthCheck) Name() string {
    return "database"
}

type FirestoreHealthCheck struct {
    client *firestore.Client
}

func (f *FirestoreHealthCheck) Check(ctx context.Context) error {
    _, err := f.client.Collection("health").Doc("test").Get(ctx)
    if err != nil && status.Code(err) != codes.NotFound {
        return err
    }
    return nil
}

func (f *FirestoreHealthCheck) Name() string {
    return "firestore"
}

// å¥åº·æ£€æŸ¥ç«¯ç‚¹
func (h *HealthChecker) HandleHealthCheck(c *gin.Context) {
    ctx, cancel := context.WithTimeout(c.Request.Context(), 10*time.Second)
    defer cancel()
    
    results := make(map[string]interface{})
    allHealthy := true
    
    for name, check := range h.checks {
        if err := check.Check(ctx); err != nil {
            results[name] = map[string]interface{}{
                "status": "unhealthy",
                "error":  err.Error(),
            }
            allHealthy = false
        } else {
            results[name] = map[string]interface{}{
                "status": "healthy",
            }
        }
    }
    
    status := "healthy"
    httpStatus := 200
    if !allHealthy {
        status = "unhealthy"
        httpStatus = 503
    }
    
    c.JSON(httpStatus, gin.H{
        "status": status,
        "checks": results,
        "timestamp": time.Now().UTC(),
    })
}
```

## éƒ¨ç½²æ¶æ„

### 1. Cloud RunæœåŠ¡é…ç½®

```yaml
# deploy/offer-service.yaml
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: offer-service
  annotations:
    run.googleapis.com/ingress: all
spec:
  template:
    metadata:
      annotations:
        autoscaling.knative.dev/minScale: "1"
        autoscaling.knative.dev/maxScale: "100"
        run.googleapis.com/cpu-throttling: "false"
        run.googleapis.com/memory: "512Mi"
        run.googleapis.com/cpu: "1000m"
    spec:
      containerConcurrency: 80
      containers:
      - image: gcr.io/gen-lang-client-0944935873/offer-service:latest
        ports:
        - containerPort: 8080
        env:
        - name: PROJECT_ID
          value: "gen-lang-client-0944935873"
        - name: FIRESTORE_DB
          value: "firestoredb"
        resources:
          limits:
            cpu: 1000m
            memory: 512Mi
```

### 2. URLè§£ææœåŠ¡é…ç½®ï¼ˆå¸¸é©»æœåŠ¡ï¼‰

```yaml
# deploy/url-parser-service.yaml
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: url-parser-service
  annotations:
    run.googleapis.com/ingress: all
spec:
  template:
    metadata:
      annotations:
        autoscaling.knative.dev/minScale: "1"  # å¸¸é©»å®ä¾‹
        autoscaling.knative.dev/maxScale: "10"
        run.googleapis.com/cpu-throttling: "false"
        run.googleapis.com/memory: "1Gi"       # æ›´å¤§å†…å­˜æ”¯æŒæµè§ˆå™¨å®ä¾‹
        run.googleapis.com/cpu: "2000m"       # æ›´å¤šCPUèµ„æº
    spec:
      containerConcurrency: 20  # é™ä½å¹¶å‘ä»¥ä¿è¯æ€§èƒ½
      containers:
      - image: gcr.io/gen-lang-client-0944935873/url-parser-service:latest
        ports:
        - containerPort: 8080
        env:
        - name: BROWSER_POOL_SIZE
          value: "5"
        - name: PROXY_API_URL
          valueFrom:
            secretKeyRef:
              name: proxy-config
              key: api_url
        resources:
          limits:
            cpu: 2000m
            memory: 1Gi
```

### 3. éƒ¨ç½²è¦æ±‚

**æœåŠ¡éƒ¨ç½²é¡ºåºï¼š**
1. URLè§£ææœåŠ¡ï¼ˆå¸¸é©»æœåŠ¡ï¼Œå…¶ä»–æœåŠ¡ä¾èµ–ï¼‰
2. æ•°æ®åŒæ­¥æœåŠ¡
3. Offerç®¡ç†æœåŠ¡
4. æ‰¹é‡æ“ä½œæœåŠ¡
5. AIé¢„è­¦æœåŠ¡

**å…³é”®é…ç½®ï¼š**
- ç¯å¢ƒå˜é‡å’Œå¯†é’¥é€šè¿‡Secret Managerç®¡ç†
- æ•°æ®åº“è¿ç§»è„šæœ¬éœ€åœ¨æœåŠ¡éƒ¨ç½²å‰æ‰§è¡Œ
- æœåŠ¡é—´ä¾èµ–å…³ç³»é€šè¿‡å¥åº·æ£€æŸ¥ç¡®ä¿

## æ€»ç»“

æœ¬è®¾è®¡æ–‡æ¡£æä¾›äº†ä¸Šç˜¾å¼å¹¿å‘Šç®¡ç†ç³»ç»Ÿçš„å®Œæ•´æŠ€æœ¯æ¶æ„å’Œå®ç°æ–¹æ¡ˆï¼ŒåŒ…æ‹¬ï¼š

1. **å¾®æœåŠ¡æ¶æ„ï¼š** åŸºäºCloud Runçš„å¯æ‰©å±•å¾®æœåŠ¡è®¾è®¡
2. **æ•°æ®å­˜å‚¨ï¼š** Firestore + Cloud SQLçš„æ··åˆå­˜å‚¨ç­–ç•¥
3. **å®šæ—¶ä»»åŠ¡ï¼š** Cloud Scheduler + Pub/Sub + Functionsçš„å¯é ä»»åŠ¡è°ƒåº¦
4. **å‰ç«¯ä½“éªŒï¼š** Next.js + å®æ—¶äº¤äº’çš„ä¸Šç˜¾å¼ç”¨æˆ·ä½“éªŒ
5. **å®‰å…¨æ€§ï¼š** å®Œæ•´çš„è®¤è¯ã€æˆæƒã€åŠ å¯†å’Œç›‘æ§ä½“ç³»
6. **æ€§èƒ½ä¼˜åŒ–ï¼š** ç¼“å­˜ã€æ•°æ®åº“ä¼˜åŒ–ã€å‰ç«¯æ€§èƒ½ä¼˜åŒ–ç­–ç•¥
7. **AIé›†æˆï¼š** Firebase AI Logicçš„å¤šåœºæ™¯æ·±åº¦åº”ç”¨
8. **æ•°æ®éš”ç¦»ï¼š** å¤šç”¨æˆ·SaaSçš„ä¸¥æ ¼æ•°æ®å®‰å…¨ä¿éšœ
9. **æµ‹è¯•ä½“ç³»ï¼š** å•å…ƒæµ‹è¯•ã€ç«¯åˆ°ç«¯æµ‹è¯•ã€æ€§èƒ½æµ‹è¯•çš„å®Œæ•´è¦†ç›–
10. **åŠ¨æ€é…ç½®ï¼š** åŸºäºFirestoreçš„çƒ­æ›´æ–°é…ç½®ç®¡ç†ç³»ç»Ÿ

è¯¥è®¾è®¡å……åˆ†åˆ©ç”¨äº†Google Cloud Platformçš„æŠ€æœ¯æ ˆï¼Œå®ç°äº†é«˜æ€§èƒ½ã€å¯æ‰©å±•ã€å®‰å…¨å¯é çš„å¹¿å‘Šç®¡ç†å¹³å°ï¼Œä¸ºç”¨æˆ·æä¾›"ä¸Šç˜¾"çš„ä½¿ç”¨ä½“éªŒï¼ŒåŒæ—¶ç¡®ä¿äº†ç³»ç»Ÿçš„å¯ç»´æŠ¤æ€§ã€å¯æµ‹è¯•æ€§å’Œå¯æ‰©å±•æ€§ã€‚