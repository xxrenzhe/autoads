generator client {
  provider      = "prisma-client-js"
  // 运行时镜像基于 Debian(glibc)，构建阶段使用 Alpine(musl)。
  // 为避免运行时查询引擎不匹配，显式生成两种二进制目标。
  binaryTargets = ["native", "debian-openssl-3.0.x", "linux-musl-openssl-3.0.x", "linux-arm64-openssl-3.0.x"]
}

datasource db {
  provider               = "mysql"
  url                    = env("DATABASE_URL")
  referentialIntegrity   = "prisma"
}

model User {
  id                                             String                   @id @default(cuid())
  email                                          String                   @unique
  name                                           String?
  avatar                                         String?
  emailVerified                                  Boolean                  @default(false)
  role                                           UserRole                 @default(USER)
  status                                         UserStatus               @default(ACTIVE) // 账户状态: ACTIVE(正常), INACTIVE(未激活), SUSPENDED(暂停), BANNED(封禁)
  createdAt                                      DateTime                 @default(now())
  updatedAt                                      DateTime                 @updatedAt
  lastLoginAt                                    DateTime?
  loginCount                                     Int                      @default(0)
  preferences                                    Json?
  stripeCustomerId                               String?                  @unique
  tokenBalance                                   Int                      @default(0)
  tokenUsedThisMonth                             Int                      @default(0)
  invitedById                                    String?
  activityTokenBalance                           Int                      @default(0)
  password                                       String?
  purchasedTokenBalance                          Int                      @default(0)
  subscriptionTokenBalance                       Int                      @default(0)
  trialUsed                                      Boolean                  @default(false)
  accounts                                       Account[]
  adminLogs                                      AdminLog[]               @relation("AdminLogs")
  api_access_logs                                ApiAccessLog[]
  apiUsages                                      ApiUsage[]               @relation("ApiUsages")
  audit_logs                                     AuditLog[]
  autoClickTasks                                 AutoClickTask[]
  checkIns                                       CheckIn[]
  config_change_history                          config_change_history[]
  configuration_history                          configuration_history[]
  createdEnvVars                                 EnvironmentVariable[]    @relation("CreatedByUser")
  updatedEnvVars                                 EnvironmentVariable[]    @relation("UpdatedByUser")
  invitedBy                                      Invitation?              @relation("InvitedUser")
  invitations                                    Invitation[]             @relation("InviterUser")
  notification_logs                              notification_logs[]
  payments                                       Payment[]
  sessions                                       Session[]
  subscriptions                                  Subscription[]
  system_configs_system_configs_createdByTousers SystemConfig[]           @relation("system_configs_createdByTousers")
  systemConfigs                                  SystemConfig[]           @relation("SystemConfigs")
  tokenPurchases                                 TokenPurchase[]
  tokenTransactions                              TokenTransaction[]
  token_usage                                    token_usage[]
  usageLogs                                      UsageLog[]
  userActivities                                 UserActivity[]           @relation("UserActivities")
  behaviorAnalytics                              UserBehaviorAnalytics[]
  devices                                        UserDevice[]
  userRestrictions                               UserRestriction[]
  users                                          User?                    @relation("usersTousers", fields: [invitedById], references: [id])
  other_users                                    User[]                   @relation("usersTousers")
  changedSubscriptions                           SubscriptionHistory[]    @relation("ChangedSubscriptions")
  queuedInvitationRewards                        QueuedInvitationReward[]
  adsAccounts                                    AdsAccount[]
  adsConfigurations                              AdsConfiguration[]
  adsExecutions                                  AdsExecution[]

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model UserRestriction {
  id        String          @id @default(cuid()) @db.VarChar(191)
  userId    String          @db.VarChar(191)
  type      RestrictionType
  reason    String          @db.VarChar(191)
  expiresAt DateTime
  isActive  Boolean         @default(true)
  createdAt DateTime        @default(now())
  updatedAt DateTime        @default(now()) @updatedAt
  user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, type])
  @@index([expiresAt])
  @@index([isActive])
  @@map("user_restrictions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Plan {
  id                      String                   @id @default(cuid())
  name                    String
  description             String?
  price                   Float
  currency                String                   @default("USD")
  interval                Interval                 @default(MONTH)
  features                Json
  metadata                Json?
  isActive                Boolean                  @default(true)
  createdAt               DateTime                 @default(now())
  updatedAt               DateTime                 @updatedAt
  limits                  Json?
  sortOrder               Int                      @default(0)
  stripePriceId           String?
  stripeYearlyPriceId     String?
  tokenQuota              Int                      @default(0)
  tokenReset              String                   @default("MONTHLY")
  billingPeriod           String                   @default("MONTHLY")
  rateLimit               Int                      @default(100)
  extraTokenOptions       Json?
  allowExtraTokens        Boolean?                 @default(true)
  subscriptions           Subscription[]
  token_usage             token_usage[]
  planFeatures            PlanFeature[]
  previousPlans           SubscriptionHistory[]    @relation("PreviousPlan")
  newPlans                SubscriptionHistory[]    @relation("NewPlan")
  queuedInvitationRewards QueuedInvitationReward[]

  @@map("plans")
}

model PlanFeature {
  id          String   @id @default(cuid())
  planId      String
  featureName String
  enabled     Boolean  @default(true)
  limit       Int?
  metadata    Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  plan        Plan     @relation(fields: [planId], references: [id], onDelete: Cascade)

  @@unique([planId, featureName])
  @@map("plan_features")
}

model Subscription {
  id                     String                @id @default(cuid())
  userId                 String
  planId                 String
  status                 SubscriptionStatus    @default(ACTIVE)
  currentPeriodStart     DateTime
  currentPeriodEnd       DateTime
  cancelAtPeriodEnd      Boolean               @default(false)
  canceledAt             DateTime?
  createdAt              DateTime              @default(now())
  updatedAt              DateTime              @updatedAt
  provider               String                @default("stripe")
  providerSubscriptionId String?
  metadata               Json?
  source                 SubscriptionSource    @default(MANUAL)
  payments               Payment[]
  plan                   Plan                  @relation(fields: [planId], references: [id])
  user                   User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscriptionHistory    SubscriptionHistory[]

  @@map("subscriptions")
}

model Payment {
  id             String        @id @default(cuid())
  userId         String
  subscriptionId String?
  amount         Float
  currency       String        @default("USD")
  status         PaymentStatus @default(PENDING)
  provider       String        @default("stripe")
  providerId     String?
  metadata       Json?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("payments")
}

model UsageLog {
  id       String   @id @default(cuid())
  userId   String
  feature  String
  usage    Int
  date     DateTime @default(now())
  metadata Json?
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, date])
  @@map("usage_logs")
}

model UserDevice {
  id           String   @id @default(cuid()) @db.VarChar(191)
  userId       String
  fingerprint  String
  userAgent    String?
  firstIP      String?
  lastIP       String?
  firstSeenAt  DateTime @default(now()) @db.Timestamp(6)
  lastSeenAt   DateTime @default(now()) @db.Timestamp(6)
  isSuspicious Boolean  @default(false)
  createdAt    DateTime @default(now()) @db.Timestamp(6)
  updatedAt    DateTime @default(now()) @updatedAt @db.Timestamp(6)
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([userId, fingerprint])
  @@index([fingerprint])
  @@index([lastSeenAt], map: "user_devices_last_seen_at_idx")
  @@map("user_devices")
}

model EnvironmentVariable {
  id        String   @id @default(cuid())
  key       String   @unique
  value     String
  isSecret  Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String
  updatedBy String?
  creator   User     @relation("CreatedByUser", fields: [createdBy], references: [id])
  updater   User?    @relation("UpdatedByUser", fields: [updatedBy], references: [id])

  @@map("environment_variables")
}

model AdminLog {
  id        String   @id @default(cuid())
  action    String
  details   Json?
  userId    String
  createdAt DateTime @default(now())
  user      User     @relation("AdminLogs", fields: [userId], references: [id])

  @@index([userId, createdAt])
  @@map("admin_logs")
}

model UserActivity {
  id        String   @id @default(cuid())
  userId    String
  action    String
  resource  String
  metadata  Json?
  timestamp DateTime @default(now())
  user      User     @relation("UserActivities", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, timestamp])
  @@index([action, timestamp])
  @@map("user_activities")
}

model ApiUsage {
  id            String   @id @default(cuid())
  userId        String
  endpoint      String
  method        String
  statusCode    Int
  responseTime  Int
  tokenConsumed Int      @default(0)
  timestamp     DateTime @default(now())
  user          User     @relation("ApiUsages", fields: [userId], references: [id], onDelete: Cascade)

  @@index([endpoint, timestamp])
  @@index([userId, timestamp])
  @@map("api_usages")
}

model ServiceConfig {
  id          String    @id @default(cuid())
  serviceName String    @unique
  config      Json
  status      String    @default("inactive")
  lastChecked DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@map("service_configs")
}

model SystemConfig {
  id          BigInt   @id @default(autoincrement()) @map("id")
  key         String   @unique @map("config_key")
  value       String?  @map("config_value")
  category    String   @default("system")
  description String?
  isSecret    Boolean  @default(false) @map("is_secret")
  isActive    Boolean  @default(true)  @map("is_active")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt      @map("updated_at")
  createdBy   String   @default("system") @map("created_by")
  updatedBy   String   @default("system") @map("updated_by")
  // Optional relation for convenience; no DB FK required (referentialIntegrity = "prisma")
  user        User?    @relation("SystemConfigs", fields: [updatedBy], references: [id])

  @@index([category])
  @@index([isSecret], map: "idx_system_configs_is_secret")
  @@map("system_configs")
}

model AuditLog {
  id         String   @id @default(cuid())
  userId     String?
  action     String
  resource   String
  resourceId String?
  details    Json?
  ipAddress  String?
  userAgent  String?
  sessionId  String?
  severity   String
  category   String
  outcome    String
  metadata   Json?
  timestamp  DateTime @default(now())
  users      User?    @relation(fields: [userId], references: [id])

  @@index([category, timestamp])
  @@index([ipAddress, timestamp])
  @@index([severity, timestamp])
  @@index([userId, timestamp])
  @@map("audit_logs")
}

model SecurityThreat {
  id                 String    @id @default(cuid())
  type               String
  severity           String
  description        String
  indicators         Json?
  affectedResources  Json?
  recommendedActions Json?
  triggeringEventId  String?
  status             String    @default("detected")
  notes              String?
  detectedAt         DateTime  @default(now())
  resolvedAt         DateTime?

  @@index([severity, detectedAt])
  @@index([status, detectedAt])
  @@index([type, status])
  @@map("security_threats")
}

model ApiPerformanceLog {
  id              String   @id @default(cuid())
  requestId       String   @unique
  method          String
  url             String
  userAgent       String?
  clientIp        String?
  statusCode      Int
  responseTime    Int
  responseSize    Int      @default(0)
  memoryHeapUsed  BigInt?
  memoryHeapTotal BigInt?
  memoryRss       BigInt?
  cpuUser         BigInt?
  cpuSystem       BigInt?
  error           String?
  timestamp       DateTime @default(now())

  @@index([responseTime])
  @@index([timestamp])
  @@index([method, url])
  @@map("api_performance_logs")
}

model ApiAccessLog {
  id         String   @id @default(cuid())
  userId     String?
  endpoint   String
  method     String
  statusCode Int
  duration   Int
  ipAddress  String
  userAgent  String?
  createdAt  DateTime @default(now())
  users      User?    @relation(fields: [userId], references: [id])

  @@index([endpoint, createdAt])
  @@index([userId, createdAt])
  @@map("api_access_logs")
}

model NotificationTemplate {
  id                String              @id @default(cuid())
  name              String              @unique
  type              NotificationType
  subject           String?
  content           String
  variables         Json?
  isActive          Boolean             @default(true)
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  notification_logs notification_logs[]

  @@map("notification_templates")
}

model UserBehaviorAnalytics {
  id             String   @id @default(cuid())
  userId         String
  feature        String
  action         String
  tokensConsumed Int      @default(0)
  duration       Int
  success        Boolean  @default(true)
  errorMessage   String?
  metadata       Json?
  ipAddress      String?
  userAgent      String?
  createdAt      DateTime @default(now())
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([feature, createdAt])
  @@index([userId, createdAt])
  @@map("user_behavior_analytics")
}

model config_change_history {
  id        String   @id @default(cuid())
  configKey String
  oldValue  String?
  newValue  String
  changedBy String
  reason    String?
  createdAt DateTime @default(now())
  users     User     @relation(fields: [changedBy], references: [id])

  @@index([configKey, createdAt])
}

model notification_logs {
  id                     String               @id
  userId                 String
  templateId             String
  type                   NotificationType
  recipient              String
  status                 NotificationStatus   @default(PENDING)
  errorMessage           String?
  sentAt                 DateTime?
  deliveredAt            DateTime?
  createdAt              DateTime             @default(now())
  notification_templates NotificationTemplate @relation(fields: [templateId], references: [id])
  users                  User                 @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([status, createdAt])
  @@index([userId, createdAt])
}

model performance_alerts {
  id         String    @id
  type       String
  severity   String
  message    String
  endpoint   String?
  requestId  String?
  metadata   Json?
  resolved   Boolean   @default(false)
  createdAt  DateTime  @default(now())
  resolvedAt DateTime?

  @@index([resolved, severity, createdAt])
  @@index([type, createdAt])
}

model TokenPurchase {
  id         String   @id @default(cuid())
  userId     String
  tokens     Int
  amount     Float
  currency   String   @default("USD")
  status     String   @default("PENDING")
  provider   String   @default("stripe")
  providerId String?
  metadata   Json?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("token_purchases")
}

model TokenTransaction {
  id            String             @id @default(cuid())
  userId        String
  type          String
  amount        Int
  balanceBefore Int
  balanceAfter  Int
  source        String?
  description   String?
  metadata      Json?
  createdAt     DateTime           @default(now())
  feature       tokenusagefeature? @default(OTHER)
  user          User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@map("token_transactions")
}

model CheckIn {
  id          String   @id @default(cuid())
  userId      String
  date        DateTime @default(now())
  tokens      Int
  streak      Int
  rewardLevel Int      @default(1)
  createdAt   DateTime @default(now())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date])
  @@index([userId, date])
  @@map("check_ins")
}

model Invitation {
  id           String    @id @default(cuid())
  inviterId    String
  invitedId    String?   @unique
  code         String    @unique
  status       String    @default("PENDING")
  email        String?
  tokensReward Int       @default(0)
  metadata     Json?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @default(now()) @updatedAt
  expiresAt    DateTime?
  acceptedAt   DateTime?
  invited      User?     @relation("InvitedUser", fields: [invitedId], references: [id])
  inviter      User      @relation("InviterUser", fields: [inviterId], references: [id], onDelete: Cascade)

  @@index([inviterId, createdAt])
  @@map("invitations")
}

model token_usage {
  id              String            @id @default(cuid())
  userId          String
  tokensConsumed  Int
  tokensRemaining Int
  planId          String
  createdAt       DateTime          @default(now())
  batchId         String?
  isBatch         Boolean           @default(false)
  itemCount       Int?
  metadata        Json?
  operation       String?
  feature         tokenusagefeature
  plans           Plan              @relation(fields: [planId], references: [id])
  users           User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([batchId])
}

model configuration_history {
  id        String   @id @default(dbgenerated("gen_random_uuid()"))
  configKey String
  oldValue  String?
  newValue  String?
  changedBy String
  reason    String?
  createdAt DateTime @default(now()) @db.Timestamp(6)
  users     User     @relation(fields: [changedBy], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@index([changedBy], map: "configuration_history_changed_by_idx")
  @@index([configKey], map: "configuration_history_config_key_idx")
  @@index([createdAt], map: "configuration_history_created_at_idx")
}

model AutoClickTask {
  id          String               @id @default(cuid())
  userId      String
  name        String
  description String?
  url         String
  selector    String
  country     String?
  status      String               @default("pending")
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
  user        User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  dailyPlans  DailyExecutionPlan[]

  @@map("auto_click_tasks")
}

model DailyExecutionPlan {
  id               String                  @id @default(cuid())
  taskId           String
  executionDate    DateTime                @default(now())
  status           String                  @default("pending")
  task             AutoClickTask           @relation(fields: [taskId], references: [id], onDelete: Cascade)
  dailySummaries   DailyExecutionSummary[]
  hourlyExecutions HourlyExecutionDetail[]

  @@unique([taskId, executionDate])
  @@map("daily_execution_plans")
}

model DailyExecutionSummary {
  id               String             @id @default(cuid())
  planId           String
  totalClicks      Int                @default(0)
  successfulClicks Int                @default(0)
  failedClicks     Int                @default(0)
  executionDate    DateTime           @default(now())
  plan             DailyExecutionPlan @relation(fields: [planId], references: [id], onDelete: Cascade)

  @@map("daily_execution_summaries")
}

model HourlyExecutionDetail {
  id       String             @id @default(cuid())
  planId   String
  hour     Int
  clicks   Int                @default(0)
  success  Int                @default(0)
  failed   Int                @default(0)
  metadata Json?
  plan     DailyExecutionPlan @relation(fields: [planId], references: [id], onDelete: Cascade)

  @@unique([planId, hour])
  @@map("hourly_execution_details")
}

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  BANNED
}

enum RestrictionType {
  API_LIMIT
  BATCH_LIMIT
  ACCOUNT_SUSPEND
  LOGIN_BLOCK
  FEATURE_ACCESS
}

enum Interval {
  DAY
  WEEK
  MONTH
  YEAR
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  EXPIRED
  PENDING
  PAST_DUE
}

enum SubscriptionSource {
  STRIPE
  MANUAL
  SYSTEM
  INVITATION
}

enum SubscriptionChangeReason {
  UPGRADE
  DOWNGRADE
  CANCELLATION
  EXPIRATION
  RENEWAL
  SYSTEM_CHANGE
  MANUAL_CHANGE
}

enum SubscriptionChangeType {
  PLAN_CHANGE
  STATUS_CHANGE
  CANCELLATION
  REACTIVATION
  TRIAL_START
  TRIAL_END
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
  PARTIALLY_REFUNDED
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
  DELIVERED
}

enum NotificationType {
  EMAIL
  SMS
  SYSTEM
}

enum tokenusagefeature {
  SITERANK
  BATCHOPEN
  CHANGELINK
  AUTOCLICK
  API
  WEBHOOK
  NOTIFICATION
  REPORT
  EXPORT
  OTHER
  ADMIN
}

enum TokenType {
  FREE
  SUBSCRIPTION
  ACTIVITY
  PURCHASED
  BONUS
}

model SubscriptionHistory {
  id             String                   @id @default(cuid())
  subscriptionId String
  previousPlanId String?
  newPlanId      String?
  changeType     SubscriptionChangeType
  changeReason   SubscriptionChangeReason
  changedBy      String
  metadata       Json?
  createdAt      DateTime                 @default(now())
  subscription   Subscription             @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  previousPlan   Plan?                    @relation("PreviousPlan", fields: [previousPlanId], references: [id])
  newPlan        Plan?                    @relation("NewPlan", fields: [newPlanId], references: [id])
  changedByUser  User                     @relation("ChangedSubscriptions", fields: [changedBy], references: [id])

  @@map("subscription_history")
}

model QueuedInvitationReward {
  id           String    @id @default(cuid())
  userId       String
  planId       String
  daysToAdd    Int       @default(30)
  invitationId String
  status       String    @default("PENDING") // PENDING, PROCESSED, CANCELED
  createdAt    DateTime  @default(now())
  processedAt  DateTime?
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan         Plan      @relation(fields: [planId], references: [id])

  @@index([userId, status])
  @@index([status, createdAt])
  @@map("queued_invitation_rewards")
}

// AdsCenter normalized models (with fallback reading from SystemConfig in routes)
model AdsAccount {
  id          String   @id @default(cuid())
  userId      String
  accountId   String
  accountName String
  status      String   @default("active")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, accountId])
  @@index([userId, createdAt])
  @@map("ads_accounts")
}

model AdsConfiguration {
  id          String         @id @default(cuid())
  userId      String
  name        String
  description String?
  payload     Json
  status      String         @default("active")
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  executions  AdsExecution[]

  @@index([userId, createdAt])
  @@map("ads_configurations")
}

model AdsExecution {
  id              String           @id @default(cuid())
  userId          String
  configurationId String
  status          String           @default("created")
  message         String?
  progress        Int              @default(0)
  totalItems      Int              @default(0)
  processedItems  Int              @default(0)
  startedAt       DateTime?        @db.Timestamp(6)
  completedAt     DateTime?        @db.Timestamp(6)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  configuration   AdsConfiguration @relation(fields: [configurationId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([configurationId, createdAt])
  @@map("ads_executions")
}

// =====================
// Admin/RateLimit models
// =====================

model AdminUser {
  id         BigInt   @id @default(autoincrement()) @map("id")
  username   String
  email      String   @unique
  password   String
  role       String   @default("admin")
  isActive   Boolean  @default(true) @map("is_active")
  lastLogin  DateTime? @map("last_login_at")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  @@map("admin_users")
}

model RateLimitConfig {
  id         String   @id @map("id")
  plan       String
  feature    String
  perMinute  Int      @default(60)  @map("per_minute")
  perHour    Int      @default(1000) @map("per_hour")
  concurrent Int      @default(0)
  isActive   Boolean  @default(true) @map("is_active")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt      @map("updated_at")

  @@index([plan])
  @@index([feature])
  @@index([isActive])
  @@map("rate_limit_configs")
}

model TokenPackage {
  id          BigInt   @id @default(autoincrement()) @map("id")
  name        String   @unique
  tokenAmount Int       @map("token_amount")
  price       Float
  bonusTokens Int       @default(0) @map("bonus_tokens")
  description String?
  isActive    Boolean   @default(true) @map("is_active")
  sortOrder   Int       @default(0) @map("sort_order")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt      @map("updated_at")

  @@index([isActive])
  @@index([sortOrder])
  @@map("token_packages")
}

model TokenConsumptionRule {
  id         BigInt   @id @default(autoincrement()) @map("id")
  service    String
  action     String
  tokenCost  Int      @map("token_cost")
  description String?
  isActive   Boolean  @default(true) @map("is_active")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt      @map("updated_at")

  @@unique([service, action])
  @@index([service])
  @@index([isActive])
  @@map("token_consumption_rules")
}

// =====================
// Batch processing models
// =====================

model BatchJob {
  id        String   @id @map("id")
  userId    String   @map("user_id")
  type      String
  status    String
  options   Json?
  createdAt DateTime @map("created_at")
  updatedAt DateTime @map("updated_at")
  items     BatchJobItem[]
  progress  BatchJobProgress?

  @@index([userId], map: "idx_batch_jobs_user")
  @@index([status], map: "idx_batch_jobs_status")
  @@index([type], map: "idx_batch_jobs_type")
  @@map("batch_jobs")
}

model BatchJobItem {
  id        String   @id @map("id")
  jobId     String   @map("job_id")
  url       String
  status    String
  result    Json?
  retries   Int      @default(0)
  lastError String?  @map("last_error")
  createdAt DateTime @map("created_at")
  updatedAt DateTime @map("updated_at")
  job       BatchJob @relation(fields: [jobId], references: [id])

  @@index([jobId], map: "idx_batch_job_items_job")
  @@index([status], map: "idx_batch_job_items_status")
  @@map("batch_job_items")
}

model BatchJobProgress {
  jobId      String   @id @map("job_id")
  total      Int      @default(0)
  success    Int      @default(0)
  fail       Int      @default(0)
  running    Int      @default(0)
  startedAt  DateTime? @map("started_at")
  finishedAt DateTime? @map("finished_at")
  updatedAt  DateTime  @map("updated_at")
  job        BatchJob  @relation(fields: [jobId], references: [id])

  @@map("batch_job_progress")
}

// =====================
// AdsCenter v2 (offers/bindings/rotations)
// =====================

model AdsOffer {
  id        String   @id
  userId    String   @map("user_id")
  offerUrl  String   @map("offer_url")
  status    String   @default("active")
  createdAt DateTime @map("created_at")
  updatedAt DateTime @map("updated_at")
  bindings  AdsOfferBinding[]

  @@index([userId], map: "idx_ads_offers_user")
  @@index([status], map: "idx_ads_offers_status")
  @@map("ads_offers")
}

model AdsOfferBinding {
  id               String   @id
  offerId          String   @map("offer_id")
  userId           String   @map("user_id")
  accountId        String   @map("account_id")
  rotationFrequency String  @map("rotation_frequency")
  rotationAt       String?  @map("rotation_at")
  uniqueWindowDays Int      @default(90) @map("unique_window_days")
  createdAt        DateTime @map("created_at")
  updatedAt        DateTime @map("updated_at")
  offer            AdsOffer @relation(fields: [offerId], references: [id])
  rotations        AdsOfferRotation[]

  @@index([offerId], map: "idx_ads_bindings_offer")
  @@index([userId], map: "idx_ads_bindings_user")
  @@index([accountId], map: "idx_ads_bindings_account")
  @@map("ads_offer_bindings")
}

model AdsOfferRotation {
  id           String   @id
  bindingId    String   @map("binding_id")
  accountId    String   @map("account_id")
  rotatedAt    DateTime @map("rotated_at")
  finalUrl     String   @map("final_url")
  finalUrlSuffix String @map("final_url_suffix")
  finalHash    String   @map("final_hash")
  status       String
  message      String?
  binding      AdsOfferBinding @relation(fields: [bindingId], references: [id])

  @@index([bindingId], map: "idx_ads_rotations_binding")
  @@index([accountId], map: "idx_ads_rotations_account")
  @@index([finalHash], map: "idx_ads_rotations_hash")
  @@map("ads_offer_rotations")
}

// =====================
// Autoclick v2 tables
// =====================

model AutoclickSchedule {
  id           String   @id
  userId       String   @map("user_id")
  name         String
  urls         Json
  timezone     String
  timeWindow   String   @map("time_window")
  dailyTarget  Int      @map("daily_target")
  refererType  String   @default("") @map("referer_type")
  refererValue String   @default("") @map("referer_value")
  proxyUrl     String?  @map("proxy_url")
  status       String   @default("DISABLED")
  lastRunAt    DateTime? @map("last_run_at")
  nextRunAt    DateTime? @map("next_run_at")
  createdAt    DateTime  @map("created_at")
  updatedAt    DateTime  @map("updated_at")

  @@index([userId], map: "idx_autoclick_schedules_user")
  @@index([status], map: "idx_autoclick_schedules_status")
  @@map("autoclick_schedules")
}

model AutoclickDailyPlan {
  id          String   @id
  scheduleId  String   @map("schedule_id")
  userId      String   @map("user_id")
  date        String
  distribution Json
  variance     Float    @default(0.3)
  weightProfile String  @default("default") @map("weight_profile")
  createdAt    DateTime @map("created_at")
  schedule     AutoclickSchedule @relation(fields: [scheduleId], references: [id])

  @@unique([scheduleId, date], map: "uniq_schedule_date")
  @@index([userId], map: "idx_autoclick_plans_user")
  @@map("autoclick_daily_plans")
}

model AutoclickExecution {
  id          String   @id
  scheduleId  String   @map("schedule_id")
  userId      String   @map("user_id")
  date        String
  status      String
  message     String?
  progress    Int      @default(0)
  success     Int      @default(0)
  fail        Int      @default(0)
  total       Int      @default(0)
  startedAt   DateTime? @map("started_at")
  completedAt DateTime? @map("completed_at")
  createdAt   DateTime  @map("created_at")
  updatedAt   DateTime  @map("updated_at")
  schedule    AutoclickSchedule @relation(fields: [scheduleId], references: [id])

  @@index([userId], map: "idx_autoclick_exec_user")
  @@index([scheduleId], map: "idx_autoclick_exec_schedule")
  @@index([date], map: "idx_autoclick_exec_date")
  @@map("autoclick_executions")
}

model AutoclickExecutionSnapshot {
  id           String   @id
  executionId  String   @map("execution_id")
  hour         Int
  success      Int      @default(0)
  fail         Int      @default(0)
  total        Int      @default(0)
  failedUrls   Json?    @map("failed_urls")
  createdAt    DateTime @map("created_at")
  execution    AutoclickExecution @relation(fields: [executionId], references: [id])

  @@index([executionId], map: "idx_autoclick_snapshot_exec")
  @@map("autoclick_execution_snapshots")
}

model AutoclickURLFailure {
  id                    String   @id
  userId                String   @map("user_id")
  urlHash               String   @map("url_hash")
  url                   String
  httpFailConsecutive   Int      @default(0) @map("http_fail_consecutive")
  browserFailConsecutive Int     @default(0) @map("browser_fail_consecutive")
  lastFailAt            DateTime? @map("last_fail_at")
  preferBrowserUntil    DateTime? @map("prefer_browser_until")
  notes                 String?
  createdAt             DateTime @map("created_at")
  updatedAt             DateTime @map("updated_at")

  @@index([userId], map: "idx_autoclick_fail_user")
  @@index([urlHash], map: "idx_autoclick_fail_hash")
  @@map("autoclick_url_failures")
}

// =====================
// Ads metrics daily
// =====================

model AdsMetricsDaily {
  id              BigInt   @id @default(autoincrement())
  userId          String   @map("user_id")
  accountId       String   @map("account_id")
  date            DateTime
  campaignId      String   @map("campaign_id")
  adGroupId       String   @map("ad_group_id")
  device          String
  network         String
  clicks          BigInt
  impressions     BigInt
  costMicros      BigInt   @map("cost_micros")
  conversions     BigInt
  convValueMicros BigInt   @map("conv_value_micros")
  vtc             BigInt
  createdAt       DateTime @map("created_at")
  updatedAt       DateTime @map("updated_at")

  @@index([userId], map: "idx_ads_metrics_user")
  @@index([accountId], map: "idx_ads_metrics_account")
  @@index([date], map: "idx_ads_metrics_date")
  @@index([campaignId], map: "idx_ads_metrics_campaign")
  @@index([adGroupId], map: "idx_ads_metrics_adgroup")
  @@map("ads_metrics_daily")
}
